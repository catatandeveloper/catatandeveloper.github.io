[{"content":" Saat mengakses internet, pernah mengalami kondisi seperti ini?\nWebsite tertentu tidak bisa dibuka di WiFi, tapi lancar saat pakai hotspot HP Domain baru (misalnya GitHub Pages + custom domain) tidak resolve ping domain.com â†’ Name or service not known Banyak orang mengira masalahnya ada di server website, padahal sering kali penyebab utamanya adalah DNS.\nArtikel ini akan membahas:\nApa itu DNS secara singkat Kenapa DNS router sering bermasalah Cara setting DNS per-WiFi Cara setting DNS global (rekomendasi) Contoh di Linux dan Windows Apa itu DNS dan Kenapa Penting? DNS (Domain Name System) adalah sistem yang menerjemahkan:\ncatatandeveloper.id â†’ 185.199.xxx.xxx Tanpa DNS:\nBrowser tidak tahu IP tujuan\nWebsite tidak bisa dibuka\nSecara default, DNS biasanya diberikan oleh:\nRouter\nRouter mendapat DNS dari ISP\nMasalahnya:\nDNS bawaan router / ISP sering lambat, cache error, atau tidak update. Inilah kenapa:\nWebsite bisa dibuka di jaringan HP Tapi gagal di WiFi rumah Kenapa Mengganti DNS Bisa Mengatasi Masalah? DNS publik seperti:\nGoogle DNS â†’ 8.8.8.8, 8.8.4.4 Cloudflare DNS â†’ 1.1.1.1, 1.0.0.1 Biasanya:\nLebih cepat Update DNS record lebih cepat Lebih stabil untuk domain baru (GitHub Pages, Vercel, Netlify, dll) Dua Cara Setting DNS di Client Setting DNS Per-WiFi (Per Koneksi) â¡ï¸ DNS hanya berlaku untuk WiFi tertentu\nKelebihan:\nFleksibel\nTidak mengganggu jaringan lain\nKekurangan:\nGanti WiFi â†’ bisa perlu setting ulang Setting DNS Global (Semua Koneksi) â­ Rekomendasi â¡ï¸ DNS berlaku untuk:\nSemua WiFi\nSemua jaringan\nTidak peduli router mana\nIni solusi paling stabil untuk developer.\nCara Setting DNS Per-WiFi (Linux â€“ NetworkManager) Contoh koneksi:\nwifi1 1. Set DNS manual\nsudo nmcli connection modify \u0026#34;wifi1\u0026#34; ipv4.ignore-auto-dns yes sudo nmcli connection modify \u0026#34;wifi1\u0026#34; ipv4.dns \u0026#34;8.8.8.8 8.8.4.4\u0026#34; 2. Reconnect WiFi\nsudo nmcli connection up \u0026#34;wifi1\u0026#34; â¡ï¸ DNS hanya aktif untuk WiFi tersebut.\nCara Setting DNS Global di Linux (systemd-resolved) 1. Edit konfigurasi\nsudo nano /etc/systemd/resolved.conf 2. Isi bagian [Resolve]\n[Resolve] DNS=8.8.8.8 8.8.4.4 FallbackDNS=1.1.1.1 3. Restart service\nsudo systemctl restart systemd-resolved 4. (Opsional) Bersihkan cache\nsudo resolvectl flush-caches 5. resolvectl status\nPastikan muncul:\nGlobal DNS Servers: 8.8.8.8 8.8.4.4 Setting Setiap WiFi vs Global â€” Mana yang Lebih Baik? Kebutuhan Pilihan Jaringan jarang bermasalah Auto / DHCP Router ISP sering error DNS Global Developer / hosting / GitHub Pages DNS Global Jaringan kantor khusus Per-WiFi Kesimpulan DNS bukan hanya urusan server, tapi juga client Banyak masalah â€œwebsite tidak bisa dibukaâ€ sebenarnya adalah masalah DNS Mengganti DNS ke Google / Cloudflare sering jadi solusi instan DNS Global adalah solusi paling praktis dan stabil Jika kamu sering deploy website statis, backend, atau IoT dashboard, setting DNS global sangat direkomendasikan. ğŸš€ğŸš€ğŸš€.\nbaca juga https://catatandeveloper.id/memahami-directory-linux/\n","permalink":"https://catatandeveloper.id/cara-setting-dns-di-komputer-linux/","title":"Cara Setting DNS Di Komputer Linux"},{"content":" GitHub adalah platform kolaborasi terbesar bagi developer di seluruh dunia. Banyak project bersifat public, artinya siapa pun bisa melihat source code-nya. Namun, melihat dan berkontribusi adalah dua hal yang berbeda.\nMasih banyak developer yang bingung:\nKapan harus fork, kapan cukup clone Apa beda contributor dan non-contributor Kenapa tidak bisa push walaupun repo public Bagaimana alur kontribusi yang benar dan aman Artikel ini akan membahas secara lengkap dan sistematis cara melakukan kontribusi ke repository GitHub public, baik sebagai contributor (collaborator) maupun non-contributor, sesuai praktik yang benar di dunia profesional dan open-source.\nMemahami Konsep Dasar Repository Public di GitHub Repository public berarti:\nSemua orang bisa melihat source code Semua orang bisa clone Tidak semua orang bisa push ğŸ‘‰ Public â‰  bebas push\nHak push tetap dikontrol oleh permission (izin) yang diberikan oleh pemilik repository.\nPerbedaan Contributor dan Non-Contributor Sebelum masuk ke teknis, kita perlu memahami dua peran utama dalam kolaborasi GitHub.\nğŸ”¹ Non-Contributor Non-contributor adalah user yang:\nTidak terdaftar sebagai collaborator Tidak punya akses write ke repository Umumnya orang luar (open-source contributor) Hak yang dimiliki:\nâœ… Read (melihat code) âœ… Clone âŒ Push ke repo asli âŒ Create branch di repo asli ğŸ”¹ Contributor / Collaborator Contributor (atau collaborator) adalah user yang:\nDitambahkan secara resmi oleh owner repo Memiliki permission (biasanya Write) Hak yang dimiliki:\nâœ… Clone repo asli âœ… Create branch âœ… Push branch âŒ (biasanya) push langsung ke main/master jika dilindungi Alur Kontribusi untuk NON-CONTRIBUTOR (Fork Workflow) Ini adalah alur paling umum dalam project open-source.\nğŸ”¸ Kenapa Harus Fork?\nKarena:\nKamu tidak punya izin push Fork membuat salinan repo di akunmu Kamu bebas eksperimen tanpa mengganggu repo asli ğŸ”¹ Langkah 1: Fork Repository Buka repository public Klik tombol Fork (pojok kanan atas) -\u0026gt; create fork Repository akan muncul di akun GitHub kamu ğŸ”¹ Langkah 2: Clone Repository Fork git clone https://github.com/usernamekamu/project.git cd project ğŸ”¹ Langkah 3: Buat Branch Baru â— Jangan pernah kerja di branch main/master\ngit checkout -b feature/perbaikan-login ğŸ”¹ Langkah 4: Lakukan Perubahan Code Edit file Tambah fitur Fix bug Update dokumentasi ğŸ”¹ Langkah 5: Commit Perubahan git add . git commit -m \u0026#34;fix: perbaiki validasi login\u0026#34; ğŸ”¹ Langkah 6: Push ke Fork git push origin feature/perbaikan-login ğŸ”¹ Langkah 7: Buat Pull Request (PR) Buka repo fork di GitHub\nKlik Compare \u0026amp; Pull Request Pilih:\nBase repo: repo asli Base branch: main/master Jelaskan perubahan dengan jelas Create PR ğŸ‰ Selesai! Sekarang maintainer akan review kontribusimu.\nAlur Kontribusi untuk CONTRIBUTOR (Collaborator Workflow) Jika kamu sudah diberi akses Write, alurnya lebih sederhana.\nğŸ”¸ Kapan Tidak Perlu Fork?\nProject internal Team kerja Repo organisasi Kamu sering kontribusi ğŸ”¹ Langkah 1: Clone Repository Langsung git clone https://github.com/org/project.git cd project ğŸ”¹ Langkah 2: Buat Branch Baru git checkout -b feature/api-auth ğŸ”¹ Langkah 3: Kerjakan Perubahan Sama seperti biasa:\nCoding Testing Refactor ğŸ”¹ Langkah 4: Commit git add . git commit -m \u0026#34;feat: tambah autentikasi API\u0026#34; ğŸ”¹ Langkah 5: Push Branch git push origin feature/api-auth ğŸ”¹ Langkah 6: Buat Pull Request Walaupun kamu contributor:\nTetap WAJIB PR Jangan push langsung ke main/master Branch Protection: Kunci Keamanan Kolaborasi Agar kolaborasi aman, branch utama HARUS dilindungi.\nBranch yang biasanya dilindungi:\nmain master release/* Aturan yang disarankan:\nâœ… Require pull request before merging âœ… Require approval âœ… Restrict who can push Dengan ini:\nContributor tidak bisa push langsung Semua perubahan lewat review Risiko bug \u0026amp; konflik lebih kecil Kesalahan Umum yang Sering Terjadi âŒ Clone repo public lalu push (non-contributor) hasil:\n403 permission denied ğŸ‘‰ Solusi: Fork dulu\nâŒ Push langsung ke master Berbahaya:\nBisa merusak production code Bisa overwrite perubahan orang lain âŒ Fork padahal sudah collaborator Tidak salah, tapi:\nRibet PR jadi tidak perlu Alur kerja tidak efisien Kapan Harus Fork dan Kapan Harus Clone? Kondisi Fork Clone Open-source âœ… âŒ Bukan collaborator âœ… âŒ Contributor internal âŒ âœ… Project organisasi âŒ âœ… Praktik Terbaik (Best Practice) Beberapa aturan yang dipakai di industri:\nJangan commit ke main/master Selalu pakai branch feature Gunakan pesan commit yang jelas Satu PR untuk satu tujuan Jangan push force kecuali paham risikonya Review code orang lain Ringkasan Akhir Kontribusi ke GitHub public bukan soal repo-nya terbuka, tapi soal izin dan alur kerja. Non-contributor wajib menggunakan fork dan pull request, sementara contributor tetap harus bekerja lewat branch dan PR, bukan langsung ke main/master. Dengan alur ini, kolaborasi jadi lebih aman, rapi, dan profesional. ğŸš€ğŸš€ğŸš€\n","permalink":"https://catatandeveloper.id/cara-kontribusi-ke-repository-github-public/","title":"Cara Kontribusi Ke Repository Github Public"},{"content":" Pada tahap deployment aplikasi, menggunakan VPS atau VPC adalah pilihan umum karena memberikan kontrol penuh terhadap sistem operasi, konfigurasi jaringan, dan resource server. Salah satu stack yang paling sering digunakan adalah Node.js karena ringan, cepat, dan cocok untuk aplikasi web maupun realtime.\nKenapa Tidak Langsung Shared Hosting? Shared hosting memiliki keterbatasan seperti: Tidak bisa memilih versi Node.js dengan bebas Tidak mendukung process manager Sulit melakukan scaling dan monitoring Dengan VPS/VPC, kita bisa:\nMengontrol versi Node.js Menjalankan aplikasi nonstop Mengatur firewall, domain, dan SSL Mengoptimalkan performa sesuai kebutuhan aplikasi oke langsung saja kita mulai langkah-langkahnya.\nUpdate sistem sudo apt update \u0026amp;\u0026amp; sudo apt upgrade -y Install Node.js (REKOMENDASI: pakai NVM) Kenapa NVM? Bisa ganti versi Node Aman untuk user (tidak root) Cocok untuk development \u0026amp; production ringan Install NVM curl -fsSL https://raw.githubusercontent.com/nvm-sh/nvm/v0.40.1/install.sh | bash reload shell\nsource ~/.bashrc cek nvm\nnvm --version install\nnvm install --lts nvm use --lts cek node dan npm\nnode -v npm -v Install PM2 (Process Manager) PM2 menjaga app tetap hidup walau server restart.\nnpm install -g pm2 jalankan app\npm2 start app.js --name myapp auto start saat reboot\npm2 startup pm2 save cek status\npm2 status cek log\npm2 log matikan app\npm2 stop myapp Setup Firewall sudo ufw allow ssh sudo ufw allow 3000 sudo ufw enable Kesimpulan Dengan kombinasi NVM, PM2, Nginx, dan SSL, aplikasi Node.js dapat berjalan dengan baik di environment production dan siap melayani pengguna secara andal.\n","permalink":"https://catatandeveloper.id/cara-setup-nodejs-di-vps-vpc/","title":"Cara Setup Nodejs Di Vps/Vpc"},{"content":" Dalam pengembangan sistem embedded dan IoT, tampilan lokal sering dibutuhkan untuk menampilkan status perangkat, nilai sensor, atau informasi debugging tanpa harus membuka serial monitor. Salah satu solusi paling sederhana dan hemat pin adalah menggunakan LCD 16Ã—2 dengan modul I2C.\nKenapa Menggunakan LCD 16Ã—2 I2C? LCD 16Ã—2 versi paralel membutuhkan 6â€“8 pin, sedangkan versi I2C hanya membutuhkan 2 pin data.\nKeuntungan utama: Hemat pin GPIO ESP32 Wiring lebih sederhana Cocok untuk sistem IoT yang kompleks Bisa dipakai bersamaan dengan sensor lain Perangkat yang Dibutuhkan ESP32 (Dev Module / WROOM / WROVER) LCD 16Ã—2 + Modul I2C (PCF8574) Kabel jumper Arduino IDE Prinsip Kerja I2C I2C (Inter-Integrated Circuit) menggunakan dua jalur:\nSDA â†’ Data SCL â†’ Clock ESP32 mendukung I2C secara hardware dan pin-nya bisa dipetakan ulang.\nKoneksi ESP32 ke LCD 16Ã—2 I2C PH ESP32 VCC 5V (sesuai modul) GND GND SDA GPIO 21 SCL GPIO 22 Menentukan Alamat I2C LCD Alamat I2C tidak selalu sama. Umumnya:\n0x27 0x3F Gunakan I2C Scanner untuk memastikan alamat.\nKode I2C Scanner: #include \u0026lt;Wire.h\u0026gt; void setup() { Serial.begin(115200); Wire.begin(21, 22); Serial.println(\u0026#34;Scanning I2C...\u0026#34;); for (byte address = 1; address \u0026lt; 127; address++) { Wire.beginTransmission(address); if (Wire.endTransmission() == 0) { Serial.print(\u0026#34;I2C device found at 0x\u0026#34;); Serial.println(address, HEX); } } } void loop() {}\nLibrary yang Digunakan Gunakan library:\nLiquidCrystal_I2C Install melalui:\nArduino IDE â†’ Library Manager â†’ LiquidCrystal I2C -\u0026gt; by Frank de Brabander #include \u0026lt;Wire.h\u0026gt; #include \u0026lt;LiquidCrystal_I2C.h\u0026gt; // Ganti 0x27 sesuai hasil scan LiquidCrystal_I2C lcd(0x27, 16, 2); void setup() { lcd.init(); lcd.backlight(); lcd.setCursor(0, 0); lcd.print(\u0026#34;Hello Developer\u0026#34;); lcd.setCursor(0, 1); lcd.print(\u0026#34;I2C Ready\u0026#34;); } void loop() { } Tips dan Masalah Umum LCD Menyala Tapi Tidak Ada Teks Alamat I2C salah Kontras belum disetel (putar trimpot di modul) LCD Berkedip atau Error Power supply tidak stabil Kabel terlalu panjang Penutup LCD 16Ã—2 I2C tetap menjadi solusi display sederhana yang efisien dan handal untuk ESP32. Dengan pemahaman I2C dan manajemen tampilan yang baik, LCD ini sangat cocok untuk berbagai proyek embedded dan IoT. Happy Hacking!! ğŸ‰ğŸ‰ğŸ‰\n","permalink":"https://catatandeveloper.id/cara-akases-lcd16x2-i2c-dengan-esp32/","title":"Cara akses Lcd 16x2 I2C Dengan Esp32"},{"content":" Total Dissolved Solids (TDS) adalah ukuran jumlah zat terlarut (dalam ppm atau mg/L) di dalam air. Sensor TDS banyak digunakan pada sistem IoT water quality, hidroponik, akuakultur, dan monitoring air minum.\nCara Kerja Sensor TDS Sensor TDS sebenarnya tidak mengukur TDS secara langsung. Sensor ini mengukur konduktivitas listrik (EC â€“ Electrical Conductivity) air.\nSemakin banyak zat terlarut (garam, mineral, ion), maka:\nKonduktivitas meningkat Tegangan output sensor berubah Hubungan umumnya:\nTDS (ppm) â‰ˆ EC (ÂµS/cm) Ã— factor Nilai factor biasanya berada di rentang 0.5 â€“ 0.7, tergantung jenis larutan.\nKoneksi Hardware Wiring Sensor TDS ke ESP32\nTDS ESP32 VCC 3.3V / 5V (sesuai modul) GND GND AO GPIO 27 âš ï¸ Penting: Gunakan ADC1 (GPIO 32â€“39) Jangan gunakan ADC2 jika ESP32 memakai WiFi Akses Data ADC ESP32 ESP32 memiliki resolusi ADC 12-bit, sehingga:\nADC Range = 0 â€“ 4095 Konversi ADC ke tegangan:\nVoltage = ADC_value Ã— (VREF / 4095) Contoh kode dasar:\n#define TdsSensorPin 27 #define VREF 3.3 int adcValue = analogRead(TdsSensorPin); float voltage = adcValue * VREF / 4095.0; Filtering Data (Median Filter) Sensor TDS sangat sensitif terhadap noise. Oleh karena itu filtering wajib dilakukan.\nMetode yang umum digunakan adalah median filter.\n#define SCOUNT 30 int analogBuffer[SCOUNT]; int analogBufferIndex = 0; void readTds() { analogBuffer[analogBufferIndex++] = analogRead(TdsSensorPin); if (analogBufferIndex == SCOUNT) analogBufferIndex = 0; } int getMedian(int *arr, int len) { int temp[len]; memcpy(temp, arr, sizeof(temp)); sort(temp, temp + len); return temp[len / 2]; } Median filter efektif menghilangkan spike sesaat akibat noise listrik.\nPerhitungan TDS Formula umum dari modul TDS Gravity:\nfloat tdsValue = (133.42 * voltage * voltage * voltage - 255.86 * voltage * voltage + 857.39 * voltage) * kValue; Di mana:\nvoltage = hasil ADC kValue = faktor kalibrasi Konsep Kalibrasi Sensor TDS Kalibrasi bertujuan untuk menyesuaikan hasil sensor dengan nilai referensi nyata.\nAlat Kalibrasi: Larutan standar TDS (misalnya 342 ppm atau 1000 ppm)\nTDS meter digital (opsional, tapi disarankan)\nLangkah Kalibrasi Manual Siapkan larutan standar (misalnya 342 ppm) Celupkan probe TDS Baca nilai TDS dari sistem Hitung faktor kalibrasi: CALIBRATION_fACTOR = TDS_referensi / TDS_sensor Masukkan nilai k ke dalam kode contoh:\nTDS_sensor = 300 ppm TDS_referensi = 342 ppm CALIBRATION_fACTOR = 342 / 300 = 1.14 Kode Lengkap #define TDS_PIN 27 #define VREF 3.3 // analog reference voltage(Volt) of the ADC #define ADC 4096.0 // adc max #define SCOUNT 30 // sum of sample point #define CALIBRATION_fACTOR 1.360 // CAL = REAL / READ int analogBuffer[SCOUNT]; // store the analog value in the array, read from ADC int analogBufferTemp[SCOUNT]; // median filtering algorithm int GetMedianNum(int bArray[], int iFilterLen) { int bTab[iFilterLen]; for (byte i = 0; i \u0026lt; iFilterLen; i++) bTab[i] = bArray[i]; int i, j, bTemp; for (j = 0; j \u0026lt; iFilterLen - 1; j++) { for (i = 0; i \u0026lt; iFilterLen - j - 1; i++) { if (bTab[i] \u0026gt; bTab[i + 1]) { bTemp = bTab[i]; bTab[i] = bTab[i + 1]; bTab[i + 1] = bTemp; } } } if ((iFilterLen \u0026amp; 1) \u0026gt; 0) { bTemp = bTab[(iFilterLen - 1) / 2]; } else { bTemp = (bTab[iFilterLen / 2] + bTab[iFilterLen / 2 - 1]) / 2; } return bTemp; } void TdsSetup() { pinMode(TDS_PIN, INPUT); } int TdsRun(float temperature) { static float tdsValue = 0; static float averageVoltage = 0; static int analogBufferIndex = 0; static int copyIndex = 0; static unsigned long analogSampleTimepoint = millis(); //every 40 milliseconds,read the analog value from the ADC if (millis() - analogSampleTimepoint \u0026gt; 40U) { analogSampleTimepoint = millis(); analogBuffer[analogBufferIndex] = analogRead(TDS_PIN); //read the analog value and store into the buffer analogBufferIndex++; if (analogBufferIndex == SCOUNT) { analogBufferIndex = 0; } } static unsigned long printTimepoint = millis(); if (millis() - printTimepoint \u0026gt; 800U) { printTimepoint = millis(); for (copyIndex = 0; copyIndex \u0026lt; SCOUNT; copyIndex++) { analogBufferTemp[copyIndex] = analogBuffer[copyIndex]; // read the analog value more stable by the median filtering algorithm, and convert to voltage value averageVoltage = GetMedianNum(analogBufferTemp, SCOUNT) * (float)VREF / ADC; //temperature compensation formula: fFinalResult(25^C) = fFinalResult(current)/(1.0+0.02*(fTP-25.0)); float compensationCoefficient = 1.0 + 0.02 * (temperature - 25.0); //temperature compensation float compensationVoltage = averageVoltage / compensationCoefficient; //convert voltage value to tds value tdsValue = (133.42 * compensationVoltage * compensationVoltage * compensationVoltage - 255.86 * compensationVoltage * compensationVoltage + 857.39 * compensationVoltage) * CALIBRATION_fACTOR; } } return tdsValue; } void setup() { Serial.begin(115200); TdsSetup(); } void loop() { int tdsVal = TdsRun(25.0f); Serial.print(\u0026#34;tds : \u0026#34;); Serial.println(tdsVal); } Penutup Sensor TDS tidak bisa langsung akurat tanpa kalibrasi. Dengan filtering yang baik dan kalibrasi menggunakan larutan standar, ESP32 dapat digunakan sebagai sistem monitoring dengan kualitas yang lebih baik. Happy hacking!! ğŸ‰ğŸ‰ğŸ‰\n","permalink":"https://catatandeveloper.id/cara-akses-sensor-tds-esp32/","title":"Cara Akses Sensor Tds Esp32"},{"content":" Sensor pH banyak digunakan pada sistem IoT (Internet of Things), terutama di bidang pertanian, akuakultur, pengolahan air, dan monitoring lingkungan. Dengan ESP32, kita dapat membaca nilai pH secara real-time dan mengirimkannya ke server, dashboard web, atau aplikasi mobile.\nApa Itu Sensor pH? Sensor pH adalah sensor yang digunakan untuk mengukur tingkat keasaman atau kebasaan suatu larutan. Skala pH berada pada rentang:\n0 â€“ 6 : Asam 7 : Netral 8 â€“ 14 : Basa Pada proyek IoT, sensor pH biasanya digunakan untuk:\nMonitoring kualitas air Sistem hidroponik Tambak ikan atau udang Pengolahan limbah cair Cara Kerja Sensor pH Sensor pH menghasilkan tegangan analog yang berubah sesuai dengan nilai pH larutan. Tegangan ini kemudian dibaca oleh ADC (Analog to Digital Converter) pada ESP32.\nAlur sederhananya:\nLarutan â†’ Probe pH â†’ Modul pH â†’ ADC ESP32 â†’ Data Digital ESP32 memiliki ADC 12-bit, sehingga nilai bacaan berada pada rentang 0 â€“ 4095.\nWiring ESP32 ke Modul PH Hubungkan pin modul PH ke ESP32 sebagai berikut: PH ESP32 VCC 3.3V / 5V (sesuai modul) GND GND PO GPIO 34 / 35 / 32 / 33 Catatan penting: Gunakan ADC1 pada ESP32 (GPIO 32â€“39) Hindari ADC2 jika ESP32 menggunakan WiFi Program Kalibrasi #define PH_PIN 35 #define VREF 3.3 // analog reference voltage(Volt) of the ADC #define ADC 4096.0 // adc max void setup() { Serial.begin(115200); } void loop() { float value = analogRead(potPin); Serial.print(value); Serial.print(\u0026#34; | \u0026#34;); float voltage = Value * (VREF / ADC); Serial.println(voltage); delay(500); } setelah menghubungkan ph dengan esp32 kita harus melakukan kalibrasi hardware sehingga module bisa bekerja dengan baik, hubungkan input probe dengan ground sebagai berikut:\nlihat pada serial usahan nilai tegangannya di sekitar 2.50, jika belum sesui putar potensio yang dekat dengan probe. jika sudah sesui lepaskan jumper dan hubungkan dengan probe dan lanjutkan ke proses testing.\nFull Program #define PH_PIN 35 #define VREF 3.3 // analog reference voltage(Volt) of the ADC #define ADC 4096.0 // adc max #define CALIBRATION_fACTOR 21.0 int buffer_arr[10]; float PhRun(){ // Baca data analog for (int i = 0; i \u0026lt; 10; i++) { buffer_arr[i] = analogRead(PH_PIN); delay(30); } // Urutkan data (bubble sort) static int temp = 0; for (int i = 0; i \u0026lt; 9; i++) { for (int j = i + 1; j \u0026lt; 10; j++) { if (buffer_arr[i] \u0026gt; buffer_arr[j]) { temp = buffer_arr[i]; buffer_arr[i] = buffer_arr[j]; buffer_arr[j] = temp; } } } // Ambil rata-rata dari data tengah unsigned long int avgval = 0; for (int i = 2; i \u0026lt; 8; i++) avgval += buffer_arr[i]; // Konversi ke voltase ESP32 float volt = (float)avgval * VREF / ADC / 6; return -5.70 * volt + CALIBRATION_fACTOR; } void setup() { Serial.begin(115200); } void loop() { float ph = PhRun(); Serial.print(\u0026#34;pH Value: \u0026#34;); Serial.println(ph); delay(1000); } Rubah nilai CALIBRATION_fACTOR supaya nilai ph keluar nilai 7, karena pada cairan default ph bernilai 7.\ndengan ini phmu sudah berjalan dengan baik, Happy coding!! ğŸ‰ğŸ‰ğŸ‰\n","permalink":"https://catatandeveloper.id/cara-akses-sensor-ph/","title":"Cara Akses Sensor PH Dengan Esp32"},{"content":" Pernah ingin menyimpan data sensor langsung ke spreadsheet tanpa harus bikin server dulu? Ternyata, kamu bisa melakukannya hanya dengan ESP32 dan Google Apps Script. Di artikel ini, kita akan membahas cara menghubungkan ESP32 ke Google Spreadsheet secara langsung lewat HTTP.\nPersiapan Alat \u0026amp; Software Hardware:\nESP32 (WROOM atau DevKit) Software:\nArduino IDE Akun Google dengan akses ke Google Sheets install esp32 dengan arduino IDE Akun Google Service Untuk melakukan pengiriman ke spreadsheet dengan baik dan aman, kamu perlu membuat aku google service nanti service ini yang akan melakukan handle untuk meneruskan data ke spreadsheet. Kamu bisa mempelajari secara mendalam di artikel ini Service Account.\nBaik langsung saja kita eksekusi\n1. Buat project di Google Cloud Console klik create project sebelah pojok kanan seperti pada gambar\n2. Berikan nama project disini kita buat untuk contoh dengan nama \u0026ldquo;logger\u0026rdquo;. setelah itu klik create dan hasilnya seperti ini. 3. Sekarang kamu perlu membuat service account untuk project tersebut. pergi ke bagian \u0026ldquo;service account\u0026rdquo; kemudian klik \u0026ldquo;create service account\u0026rdquo;\n4. Masukan nama service account dan service account id kemudian create and continue 5. Pilih service account role owner kemudian continue setelah itu pilih done dan kemudian akan masuk dalam service account setting\n6. Buat Key baru klik titik 3 sebalah kanan dan manage keys. kemudian create new key\npilih format json dan kemudian klik create\nsetelah kamu mendapatkan data json, nanti data itu akan kamu pakai untuk mengisi parameter yang ada di code arduino.\n7. Enable Google sheet API kamu perlu melakukan enable untuk google spreadsheet API https://console.cloud.google.com/apis/library/sheets.googleapis.com 8. Enable Google Drive API kamu juga perlu untuk melakukan enable google driver ikuti link berikut https://console.cloud.google.com/apis/library/drive.googleapis.com\n9. Buat Spreadsheet baru buat Spreadsheet baru dan catat id spreadsheet ID bisa kmu lihat seperti ini https://docs.google.com/spreadsheets/d/[id]/edit?gid=0#gid=0\nESP32 kamu perlu melakukan instalasi library ESP-Google-Froms-Client seperti berikut masukan data dari json yang sudah kamu dapat tadi ke code arduino seperti dibawah.\nKhusus untuk Private Key kamu bisa menggunakan R\u0026quot;KEY(\u0026ndash;datakey\u0026ndash;)KEY\u0026quot; sesuai format c++11, atau bisa menuliskan string yang bagus setiap bariskan, kmu bisa menggunakan AI seperti chatGPT, gemini atau deepseek untuk mempermudah menjadikan code sehingga tidak error\nfull code #include \u0026lt;Arduino.h\u0026gt; #include \u0026lt;WiFi.h\u0026gt; #include \u0026lt;ESP_Google_Sheet_Client.h\u0026gt; #define WIFI_SSID \u0026#34;ssid\u0026#34; #define WIFI_PASSWORD \u0026#34;password\u0026#34; #define PROJECT_ID \u0026#34;logger-474719\u0026#34; #define CLIENT_EMAIL \u0026#34;data-log@logger-474719.iam.gserviceaccount.com\u0026#34; const char PRIVATE_KEY[] PROGMEM = R\u0026#34;KEY(-----BEGIN PRIVATE KEY----- MIIEvgIBADANBgkqhkiG9w0BAQEFAASCBKgwggSkAgEAAoIBAQDIYUnzDoYnDS+Q yE+AjmH+QDWahTPCuxU3QOL6aAjH2RF1Yq/umIP+6fjJzipvIkct+c6qdN1UI4Mk xLDObJItust7uXF99eDz8s9aXdTgXN7CD+4mxy9q/xH7P2xv+uMrat0kKDNRP0Ae tyFWPVqhYORzqPVciDGHshnnAFfqeLDlq5XLY5MAk9Q+c5oDzzxwT2GV1pb0BZoo bZyXz/kqDtiazaFFGUBCCrC8kmnyMVpcV7Gy3y18qh63mHnQ+czeBGWg0FqIFnmW pwEYUc/jajO6WZ4Q9weKtN1hCahjPnOEvzLgduXwdZFDq4nCmmM9gZ2f7TaxjLdT igT+vDN7AgMBAAECggEAEp3/aea6jhxKhBAoWtBfyGic0lt34KrTIMwViqBp2G+R kK93mxpugRup8s4F4Ud1B4+DJREwkyWthJgFuVgbCManKzqikcpreR7hJws6wRG/ 3JXwUYgGHtHOEOLmp0zPGHSYUUiu4+iVg4UOQt32crH258wV59/7ghkJEQ5WHMGp hcos/OIVIQylVaTBrkk+7Za3ztU+wojfUpLVv1h7U4J0MXd74DEBd7iOW2bvwm8g ysFbeTA7uT8mnzzBDMlyry7EjyZvx5B4Kzu5vJdD8bzRykz0DbnesTmbK4bk2Y6N VHtrCYLgvUQLWiIn4PPyu+CtaICudlDSKAg7u/ku8QKBgQD+noU83pqGDeS7hMRn ZMmpxUTSZYwVe9y5C47A6J+vv5oTPbPeRqHBNWCIh9bGWCIO6wGj7jAkkUncyVOZ NwBIbXFcf5rMlT1d2pi5EO6OF1gWUlEaNtMRVALVewJMShU58eDEHS07PXOqUBYy kYHnsYKqcd+vqaYlkFjYESB3+QKBgQDJd3hMb4lFUneq8FYjED8psZKizLBZ38To MwVFoAsicTv7uoioJGUC/fLYnsuRC5SlSyeg8CBi9Ja1ctthGrCCxgdhK9ikcQ0A KresiloG79E4ZJi1Lpuux0+XbYfelLVmrzdqejh17eBztD7GAzvlYGFGy8Ch2rwL ReMyDHisEwKBgF/Uld0VAx+VNxOEos8vVd85ye9OHO0xEx/qQ65DX2asPHclb/8m olavmkeIqMM6BIeM1681RJVewWgBth8iXk7kMhhYRpDdUp1yWqy8vKxqCNNN5Axz ufj5n59tjq3b7CVE7g2h1ZZISLI/NjuOHFBxtPYlqcTZmxjkPSwFNi0xAoGBAJMH EVAXBgMFUDf79aDZNn9jDDSrVPgCCl26/ln1lqqoILJxS1IKXX11f0j/emh8HxsS YfVdyQTuox4AmIGhTLfjdXdA3HYF2wsIIctVnKX7VqDlKVzwisVex4MneETEGi66 KKMYVyQZWfiWzkkMCyY21EcqY4a7bwh7FHduCpLpAoGBAN220cuTelgcSNf6yn9P SlqRFzMwZh/qvf6eD+4lmPWmD77OGwZt04h2O7voKOa25heOdIxpQN75fF+9mgo2 zrs3ymV3+xtNODNgj+nWSbf5OtKIkpFNQ3m/iW+sMBAD24lraGaE2RVLMsIzi9G8 RU3Voj7+ltdU6HKGGx/MmX+I -----END PRIVATE KEY----- )KEY\u0026#34;; const char spreadsheetId[] = \u0026#34;1DdrKGU5H0bQ24cSKs7895fAniZ516ZYtYYTRZem-y30\u0026#34;; unsigned long lastTime = 0; unsigned long timerDelay = 5000; void setup() { Serial.begin(115200); WiFi.setAutoReconnect(true); WiFi.begin(WIFI_SSID, WIFI_PASSWORD); Serial.print(\u0026#34;Connecting to Wi-Fi\u0026#34;); while (WiFi.status() != WL_CONNECTED) { Serial.print(\u0026#34;.\u0026#34;); delay(300); } gs_setup(); } void loop() { gs_send(\u0026#34;now\u0026#34;, millis()); } void gs_setup() { GSheet.printf(\u0026#34;ESP Google Sheet Client v%s\\n\\n\u0026#34;, ESP_GOOGLE_SHEET_CLIENT_VERSION); GSheet.setTokenCallback(tokenStatusCallback); // Set the seconds to refresh the auth token before expire (60 to 3540, default is 300 seconds) GSheet.setPrerefreshSeconds(10 * 60); GSheet.begin(CLIENT_EMAIL, PROJECT_ID, PRIVATE_KEY); } void gs_send(String date, int data) { bool ready = GSheet.ready(); if (ready \u0026amp;\u0026amp; millis() - lastTime \u0026gt; timerDelay) { lastTime = millis(); FirebaseJson response; FirebaseJson valueRange; valueRange.add(\u0026#34;majorDimension\u0026#34;, \u0026#34;COLUMNS\u0026#34;); valueRange.set(\u0026#34;values/[0]/[0]\u0026#34;, date); valueRange.set(\u0026#34;values/[1]/[0]\u0026#34;, data); // For Google Sheet API ref doc, go to https://developers.google.com/sheets/api/reference/rest/v4/spreadsheets.values/append // Append values to the spreadsheet bool success = GSheet.values.append(\u0026amp;response /* returned response */, spreadsheetId /* spreadsheet Id to append */, \u0026#34;Sheet1!A1\u0026#34; /* range to append */, \u0026amp;valueRange /* data range to append */); if (success) { response.toString(Serial, true); valueRange.clear(); } else { Serial.println(GSheet.errorReason()); } Serial.println(); Serial.println(ESP.getFreeHeap()); } } void tokenStatusCallback(TokenInfo gs_info) { if (gs_info.status == token_status_error) { GSheet.printf(\u0026#34;Token info: type = %s, status = %s\\n\u0026#34;, GSheet.getTokenType(gs_info).c_str(), GSheet.getTokenStatus(gs_info).c_str()); GSheet.printf(\u0026#34;Token error: %s\\n\u0026#34;, GSheet.getTokenError(gs_info).c_str()); } else { GSheet.printf(\u0026#34;Token info: type = %s, status = %s\\n\u0026#34;, GSheet.getTokenType(gs_info).c_str(), GSheet.getTokenStatus(gs_info).c_str()); } } upload firmware ke esp 32 dan hasilnya seperti ini\nKesimpulan Spreadsheet bisa kamu gunakan untuk melakukan logging data sehingga data tersimpan dalam cloud dan tidak perlu menggunakan server sendiri, kamu juga bisa melakukan kombinasi service pihak ke tiga untuk menampilkan UI secara realtime, pelajari selangkapnya hanya disini.ğŸ‰ğŸ‰ğŸ‰\n","permalink":"https://catatandeveloper.id/mengirim-data-spreadsheet-dengan-esp32/","title":"Mengirim Data Spreadsheet Dengan Esp32"},{"content":" Wi-Fi adalah teknologi jaringan nirkabel (tanpa kabel) yang digunakan untuk menghubungkan perangkat seperti laptop, smartphone, atau komputer ke internet menggunakan gelombang radio. Wi-Fi bekerja seperti â€œjembatan tanpa kabelâ€ antara perangkat dan router (alat pemancar internet). Router menerima sinyal internet dari modem, lalu memancarkannya melalui gelombang radio agar perangkat bisa terhubung tanpa perlu kabel LAN.\nNama dan Standar Teknis Generasi Nama Teknis Tahun Release Wi-Fi 4 802.11n 2009 Wi-Fi 5 802.11ac 2014 Wi-Fi 6 802.11ax 2019 Kecepatan Maksimal (Teoretis) Generasi Kecepatan Maksimum Frequency Wi-Fi 4 Hingga 600 Mbps 2.4 GHz \u0026 5 GHz Wi-Fi 5 Hingga 3.5 Gbps 5 GHz Wi-Fi 6 Hingga 9.6 Gbps 2.4 GHz \u0026 5 GHz (sering juga 6 GHz di Wi-Fi 6E) Teknologi Utama yang Ditingkatkan Fitur Wi-Fi 4 Wi-Fi 5 Wi-Fi 6 MU-MIMO (Multi-User MIMO) âŒ Tidak ada âœ… Downlink âœ… Uplink \u0026 Downlink OFDMA (Efisiensi Data) âŒ âŒ âœ… Ya Beamforming (Arahkan sinyal ke perangkat) âŒ âœ… Lebih Baik âœ… Sangat Presisi Konsumsi daya perangkat (Hemat baterai) âŒ âŒ âœ… Lebih efisien (Target Wake Time) Kinerja di Dunia Nyata Aspek Wi-Fi 4 Wi-Fi 5 Wi-Fi 6 Kecepatan per perangkat Lambat di area padat Cepat tapi bisa turun saat ramai Tetap cepat walau banyak pengguna Jarak jangkauan Baik (2.4 GHz) Sedang (5 GHz lebih cepat tapi pendek) Seimbang, bisa 2.4 + 5 GHz Stabilitas jaringan Mudah drop Lebih stabil Sangat stabil \u0026 responsif Cocok Untuk Apa Generasi Cocok Untuk Wi-Fi 4 Aktivitas ringan seperti browsing dan streaming 720p Wi-Fi 5 Streaming HD/4K, gaming online, rumah tangga biasa Wi-Fi 6 Smart home, IoT, gaming, kantor ramai, streaming 8K Cara Kerja Wi-Fi ISP (penyedia internet) â†’ mengirimkan koneksi ke modem. Modem â†’ meneruskan koneksi ke router Wi-Fi. Router â†’ memancarkan sinyal nirkabel (radio 2.4 GHz atau 5 GHz). Perangkat (HP, laptop, tablet, dll) â†’ menangkap sinyal dan bisa akses internet. Cara Cek Versi Wi-Fi Kita Di Windows Langkah 1. Cek Wi-Fi Card yang ada di laptop/komputer kamu, untuk mengetahuinya, silahkan buka Device Manager â†’ kemudian pada bagian Network Adaptor silahkan cek, akan akan keterangan Wi-Fi 6 AXXX maka perangkat kamu sudah mendukung koneksi jaringan tersebut. Langkah 2 Selanjutnya konek ke jaringan Wi-Fi. Langkah 3 Jika sudah terhubung, silahkan masuk ke Setting â†’ Network \u0026amp; Internet â†’ Wi-Fi â†’ Nama Wi-Fi. Dibawah SSID terdapat penjelasan protocol yang bisa dilihat apakah kamu menggunakan jaringan Wi-Fi 4,5 atau 6. Langkah Alternatif Kamu bisa menggunakan command prompt untuk mengecek versi Wi-Fi, dengan prompt berikut: Tekan Win + R â†’ cmd â†’ netsh wlan show interfaces. Jika tertulis 802.11n berarti menggunakan Wi-Fi 4, jika 802.11ac berarti Wi-Fi 5, dan 802.11ax berarti Wi-Fi 6. Kesimpulan dari laptop saya untuk Wi-Fi Card sudah mendukung Wi-Fi 6 namun laptop saya terkoneksi ke router yang masih menggunakan protocol Wi-Fi 4.\nhmmm.. sepertinya sudah saatnya saya untuk upgrade router ğŸ˜‚ğŸ˜‚\n","permalink":"https://catatandeveloper.id/penjelasan-wifi/","title":"Wi-Fi 4, 5 Dan 6. Bedanya Apa Sih??"},{"content":" TPM 2.0 (Trusted Platform Module 2.0) adalah sebuah standar internasional untuk modul keamanan berbasis hardware yang berfungsi sebagai tempat penyimpanan aman (secure cryptoprocessor) bagi kunci enkripsi, sertifikat, password, dan data sensitif lainnya. Modul ini dapat berbentuk chip fisik yang ditanam pada motherboard, atau berupa firmware TPM (fTPM) yang terintegrasi di dalam prosesor modern (misalnya Intel PTT atau AMD fTPM).\nSecara sederhana, TPM 2.0 bisa diibaratkan sebagai brankas digital di dalam komputer yang memastikan hanya software, sistem operasi, dan pengguna yang sah yang bisa mengakses data dan perangkat tersebut.\nFungsi utama TPM 2.0 Enkripsi Data â€“ mendukung fitur seperti BitLocker di Windows untuk mengunci hard disk.\nSecure Boot â€“ memastikan sistem hanya boot dari software yang asli/terpercaya, mencegah malware menyerang saat startup.\nPenyimpanan Aman â€“ menyimpan kunci kriptografi di dalam chip, bukan di hard disk yang mudah diakses.\nAutentikasi â€“ membantu verifikasi identitas perangkat dan pengguna.\nHubungan TPM 2.0 dan Windows 11 Microsoft mewajibkan TPM 2.0 untuk instalasi Windows 11. Alasannya:\nMeningkatkan perlindungan terhadap malware tingkat rendah (bootkit, rootkit).\nMenjamin keaslian sistem sejak proses boot hingga OS berjalan.\nMendukung login aman tanpa password tradisional (Windows Hello).\nMengaktifkan enkripsi default agar data pengguna lebih terlindungi.\nMemberikan standar keamanan baru untuk perangkat enterprise dan konsumen.\nPerbedaan TPM 1.2 dan TPM 2.0 Fitur TPM 1.2 TPM 2.0 Algoritma Hanya SHA-1, RSA Lebih modern: SHA-256, ECC, RSA Keamanan Sudah aman, tapi mulai usang Lebih kuat, sesuai standar keamanan baru Kompatibilitas OS Windows 7/8/10 Windows 10 (versi baru) \u0026 Windows 11 wajib Fleksibilitas Terbatas Lebih fleksibel untuk aplikasi IoT, Cloud, dan AI Cara Mengecek TPM 2.0 di Komputer Tekan Win + R â†’ ketik tpm.msc â†’ tekan Enter. Jendela Trusted Platform Module Management akan terbuka. Di bagian TPM Manufacturer Information, cek apakah Specification Version = 2.0. Jika tidak ada, coba aktifkan lewat BIOS/UEFI dengan mencari opsi Intel PTT atau AMD fTPM.\nAnalogi TPM 2.0 Bayangkan kamu punya rumah:\nRumah = Komputer/Laptop Rumahmu adalah perangkat komputer. Di dalamnya ada barang berharga (data, file, password).\nPintu Rumah = Sistem Operasi (Windows) Untuk masuk ke rumah, kamu harus lewat pintu utama. Kalau pintu gampang dibobol, pencuri bisa masuk (sama seperti OS yang mudah disusupi malware).\nBrankas di Dalam Rumah = TPM 2.0 Walaupun ada pintu, kamu juga punya brankas khusus yang:\nMenyimpan emas, surat berharga, dan dokumen penting â†’ (kunci enkripsi, password, sertifikat digital).\nBrankas ini punya kunci unik bawaan pabrik â†’ (chip TPM punya identitas unik yang tidak bisa diduplikasi).\nAlarm \u0026amp; CCTV di Rumah = Secure Boot \u0026amp; Integrity Check TPM juga bertindak seperti alarm + CCTV:\nMengecek setiap kali pintu dibuka (proses booting).\nKalau ada orang yang mencoba masuk pakai kunci palsu â†’ alarm berbunyi (boot dicegah).\nPintu Digital dengan Sidik Jari = Windows Hello + TPM Kalau kamu pasang pintu digital, kamu bisa masuk dengan sidik jari/wajah tanpa pakai kunci tradisional.\nItu sama seperti Windows Hello yang bekerja dengan bantuan TPM untuk menyimpan data biometrik secara aman.\nKesimpulan Tanpa brankas (TPM), barang berharga mudah dicuri kalau pencuri berhasil masuk.\nDengan brankas (TPM 2.0), meskipun pintu rumah berhasil dibuka, pencuri tetap tidak bisa mengambil barang paling penting karena semuanya terkunci rapat dengan kunci khusus yang tidak bisa disalin.\nSecara Umum TPM 2.0 adalah jantung keamanan Windows dan perangkat modern, tanpa chip ini komputer lebih rentan terhadap serangan siber.\n","permalink":"https://catatandeveloper.id/trusted-platform-module/","title":"Apa Itu TPM 2.0? Dan Apa Fungsinya?"},{"content":" Cache adalah tempat penyimpanan sementara untuk data yang sering digunakan, agar sistem bisa mengaksesnya lebih cepat daripada harus memproses ulang atau membaca dari penyimpanan utama (seperti hard disk atau bahkan RAM biasa). Sedangkan RAM adalah memori utama komputer/laptop yang menyimpan data dan instruksi yang sedang digunakan oleh sistem dan aplikasi secara aktif.\nMembersihkan cache RAM pada laptop bisa membantu meningkatkan kinerja sistem, terutama jika laptop terasa lambat. Perlu diketahui, RAM secara teknis akan membersihkan dirinya saat reboot, tetapi ada beberapa cara untuk \u0026ldquo;membebaskan\u0026rdquo; RAM tanpa harus restart.\nğŸ§© Cache RAM = Data sementara di RAM Cache RAM adalah data sementara yang disimpan di RAM, biasanya berisi:\nHasil kerja aplikasi yang belum disimpan permanen Data sementara browser atau software lain Sisa-sisa proses program yang sudah ditutup Tujuannya adalah:\nMempercepat proses loading aplikasi atau data yang baru saja digunakan Mengurangi beban CPU dan disk ğŸ§¹ Cara untuk membersihkan cache RAM: 1. Cara paling sederhana Restart Laptop\nMenghapus cache RAM Menutup semua proses yang berjalan 2. Gunakan Task Manager\nTekan Ctrl + Shift + Esc â†’ buka Task Manager Lihat tab Processes Klik aplikasi yang makan banyak RAM â†’ pilih End task 3. Gunakan Script Pembersih RAM\nBuka Notepad Tempel kode ini: %windir%\\system32\\rundll32.exe advapi32.dll,ProcessIdleTasks Simpan sebagai clear_ram.bat Jalankan file itu sebagai Administrator 4. Menggunakan RAMMap (gratis dari Microsoft)\nUnduh file dari situs resmi RAMMap Ekstrak file ZIP-nya ke folder pilihanmu Jalankan RAMMap.exe Klik menu Empty di atas, Pilih salah satu opsi: Empty Standby List â†’ Membersihkan cache RAM yang tidak lagi digunakan secara aktif (aman dan direkomendasikan)\nEmpty Working Sets â†’ Melepaskan memori yang digunakan oleh proses aktif (bisa membuat aplikasi jadi lambat sejenak)\nEmpty Modified Page List â†’ Membersihkan memori yang sudah dimodifikasi tapi belum ditulis ke disk\nRekomendasi: Gunakan \u0026ldquo;Empty Standby List\u0026rdquo;.\nBerikut perbedaan Cache RAM ketika menggunakan Empty Standby List: âš ï¸ Kesimpulan Membersihkan cache RAM membantu membebaskan memori, meningkatkan performa sesaat, dan mengatasi sistem yang mulai lambat, tetapi cache akan terbentuk kembali, karena bagian dari cara sistem mengoptimalkan kinerja. Jadi tidak ada salahnya untuk membersihkan cache ram secara berkala untuk menjaga laptop tetap dalam performa terbaik.\n","permalink":"https://catatandeveloper.id/cache-ram/","title":"Cache RAM Laptop Menumpuk? Hapus Aja!"},{"content":" Banyak board Arduino non-resmi (clone) seperti Arduino Uno, Nano, dan ESP32 menggunakan chip USB-to-Serial seperti CH340 atau CP210x. Jika driver-nya belum terpasang, maka board tidak akan terdeteksi oleh komputer saat kamu ingin meng-upload sketch.\nBerikut adalah panduan lengkap untuk meng-install driver CH340 dan CP210x di Windows agar Arduino IDE bisa mengenali board kamu.\nğŸ”Œ 1. Cek Chip USB-to-Serial di Board Kamu Lihat komponen kecil di dekat port USB pada board Arduino-mu. Umumnya:\nCH340: Terlihat dengan label CH340G CP210x: Label seperti CP2102 atau CP2104 ğŸ–¥ï¸ 2. Download Driver CH340 Driver:\nSitus resmi: https://sparks.gogo.co.nz/ch340.html download file dan extract double klik file eksekusi dan pilih yes klik install tunggu sampai selesai dan port akan muncul di arduino. CP210x Driver:\nSitus resmi: https://www.silabs.com/developers/usb-to-uart-bridge-vcp-drivers Pilih: \u0026ldquo;CP210x Windows Drivers\u0026rdquo; download file dan extract double klik x64 atau x32 sesuai sistem operasi install seperti biasa dan tunggu sampai selesai. Kesimpulan Dengan meng-install driver CH340 atau CP210x, board Arduino clone kamu akan dikenali oleh Windows dan bisa langsung digunakan dengan Arduino IDE. ğŸš€ğŸš€\n","permalink":"https://catatandeveloper.id/cara-install-driver-port-untuk-arduino-ide/","title":"Cara Install Driver CP210x dan CH340 Untuk Arduino IDE"},{"content":" WinPE Sergei Strelec adalah sebuah bootable live CD/USB berbasis Windows PE (Windows Preinstallation Environment) yang dibuat dan dikembangkan oleh Sergei Strelec, seorang pengembang independen dari Rusia. Tool ini dirancang untuk membantu dalam proses pemeliharaan sistem, perbaikan, backup/restore, diagnosa, dan manajemen data, terutama saat sistem operasi utama tidak bisa booting.\nğŸ—ï¸ Arsitektur Fitur Keterangan ğŸ’» Basis Sistem\tDibangun di atas Microsoft Windows Preinstallation Environment (WinPE). ğŸ—ï¸ Versi Windows Umumnya berbasis Windows 10/11 (tergantung versi Strelec yang digunakan). ğŸ§  Arsitektur CPU Mendukung dua arsitektur utama: 32-bit (x86) dan 64-bit (x64). ğŸ“¦ Boot Mode Mendukung UEFI dan Legacy BIOS (CSM). ğŸ”Œ Portable Mode Didesain untuk dijalankan secara live (tanpa instalasi), dari USB/DVD/ISO. ğŸ› ï¸ Modularitas Menggunakan banyak tool third-party dalam satu lingkungan pre-boot. ğŸ§© Kompatibilitas Komponen Kompatibilitas ğŸ§© Driver Hardware Sudah termasuk banyak driver umum: storage, LAN, chipset, USB 3.0/3.1, NVMe, dll. ğŸ§  RAM Minimum Disarankan â‰¥ 2 GB RAM (lebih tinggi lebih baik untuk kinerja maksimal). ğŸ’¾ Media Bootable Kompatibel dengan USB flashdisk, CD/DVD, dan boot via ISO dari jaringan atau PXE. ğŸ§± File System Support Mendukung NTFS, FAT32, exFAT, dan beberapa dukungan terbatas untuk EXT (Linux). âœ… Kelebihan Kategori Kelebihan ğŸ”§ Fungsi Utama Memperbaiki, memulihkan, dan mengelola sistem Windows dengan berbagai tools. ğŸ’½ Portabilitas Bisa dijalankan langsung dari USB, DVD, atau ISO tanpa perlu instalasi. ğŸ–¥ï¸ Antarmuka Antarmuka GUI berbasis Windows â€“ familiar dan mudah digunakan. ğŸ§° Kelengkapan Tools Termasuk software populer: Acronis, Macrium, Partition Wizard, dan lainnya. ğŸ”„ Multiboot Support Mendukung boot UEFI dan Legacy BIOS. ğŸ§© Dukungan Driver Sudah termasuk banyak driver untuk hardware modern. â™»ï¸ Update Berkala Versi terbaru rutin dirilis dengan peningkatan tool dan kompatibilitas. âš¡ Kinerja Cepat Ringan dan cepat saat booting karena berbasis WinPE. âŒ Kekurangan \u0026amp; Risiko Masalah Penjelasan ğŸ”’ Legalitas Diragukan Banyak software di dalamnya tidak berlisensi resmi (Acronis, dll). Penggunaan komersial bisa melanggar hukum. ğŸ› ï¸ Pembaruan Manual Tidak ada auto update. Harus download versi terbaru dari sumber tidak resmi. ğŸ› Kemungkinan Malware File ISO dari sumber tak dikenal bisa mengandung malware atau trojan. ğŸ’¡ Tidak Cocok untuk Pemula Meski GUI, alat-alatnya bisa kompleks bagi yang belum familiar. âš ï¸ Legalitas\nMeskipun sangat powerful, WinPE Sergei Strelec sering kali berisi software berlisensi yang telah di-crack atau di-modifikasi, sehingga tidak legal untuk digunakan di lingkungan komersial atau perusahaan tanpa lisensi yang sah. Hal ini membuat penggunaannya kontroversial, terutama dalam konteks hukum hak cipta.\nğŸ”§ Cara Penggunaan (Gambaran Umum)\nUnduh file ISO dari situs resmi Sergei Strelec Gunakan tool Rufus, Membuat USB Bootable Menggunakan Rufus Boot Strelec dari USB saat startup (melalui BIOS/UEFI). WinPE Sergei Strelec akan boot langsung ke antarmuka Windows PE. ğŸ–¥ï¸ Interface WINPE Sergei Strelec âš ï¸ Windows Preinstallation Environment (WinPE) yang dirancang untuk keperluan pemeliharaan, perbaikan, backup, dan pemulihan sistem komputer. Toolkit darurat Windows yang sangat kuat, fleksibel, dan berguna bagi teknisi IT, tetapi bukan sepenuhnya legal dan bukan untuk pemula.\n","permalink":"https://catatandeveloper.id/winpe-sergei-strelec/","title":"Apa Itu WinPE Sergei Strelec?"},{"content":" ESP32/ESP8266 adalah mikrokontroler favorit para maker, pengembang IoT, dan pecinta ngoprek karena fiturnya yang kaya: WiFi, Bluetooth, banyak GPIO, ADC, dan bahkan dual-core! Tapi agar ESP32/ESP8266 bisa diprogram dengan Arduino IDE, ada beberapa langkah tambahan yang harus kamu lakukan.\nYuk, ikuti langkah-langkahnya di bawah ini. Mudah kok â€” dan kamu akan siap membuat proyek keren dalam hitungan menit! ğŸ˜\nğŸ› ï¸ Persiapan Alat Sebelum mulai, pastikan kamu punya:\nArduino IDE versi terbaru (disarankan 1.8.19 atau versi 2.x) Koneksi internet Kabel USB (microUSB atau USB-C tergantung modul ESP32/ESP8266 kamu) Modul ESP32/ESP8266 ğŸ”§ Langkah-langkah Instalasi 1. Buka Arduino IDE\nKalau belum punya, download di https://www.arduino.cc/en/software\nTips: Gunakan versi standalone (bukan dari Microsoft Store) agar lebih mudah dalam pengaturan board.\n2. Tambahkan URL Board\nBuka File \u0026gt; Preferences Cari kolom \u0026ldquo;Additional Board Manager URLs\u0026rdquo; Masukkan URL berikut untuk ESP32: https://raw.githubusercontent.com/espressif/arduino-esp32/gh-pages/package_esp32_index.json Masukkan URL berikut untuk ESP8266 http://arduino.esp8266.com/stable/package_esp8266com_index.json Jika sudah ada URL lain, pisahkan dengan tanda koma , 3a. Install ESP32 Board via Board Manager\nBuka Tools \u0026gt; Board \u0026gt; Boards Manager Ketik esp32 di kolom pencarian Klik \u0026ldquo;Install\u0026rdquo; pada hasil ESP32 by Espressif Systems 3b. Install ESP8266 Board via Board Manager\nBuka Tools \u0026gt; Board \u0026gt; Boards Manager Ketik esp8266 di kolom pencarian Klik \u0026ldquo;Install\u0026rdquo; pada hasil ESP8266 by ESP8266 Community Tunggu beberapa menit (tergantung koneksi internet kamu). 4. Sambungkan ESP32/ESP8266 ke PC\nGunakan kabel USB yang mendukung data (bukan cuma cas!) Pastikan perangkat terdeteksi. Buka Tools \u0026gt; Port, pilih port COM yang muncul (contoh: COM5 di Windows, /dev/ttyUSB0 di Linux) 5. Pilih Board yang Sesuai Contoh board umum:\nESP32 Dev Module Nodemcu DOIT ESP32 DEVKIT V1 Pilih melalui menu Tools \u0026gt; Board 6. Uji Coba Program \u0026ldquo;Blink\u0026rdquo;\nBuka File \u0026gt; Examples \u0026gt; 01.Basics \u0026gt; Blink Ubah pin dari LED_BUILTIN menjadi pin yang sesuai, misalnya 2 untuk banyak board ESP32 Klik Upload (ikon panah ke kanan) Tunggu sebentar. Jika berhasil, LED akan berkedip!\nâš ï¸ Troubleshooting Gagal Upload?\nTekan dan tahan tombol BOOT di ESP32 saat proses \u0026ldquo;Connecting\u0026hellip;\u0026rdquo;, lalu lepas saat mulai mengunggah.\nTidak muncul COM port?\nPastikan driver USB sudah terinstal. Untuk Windows, coba instal CP2102 atau CH340 driver tergantung board kamu. klik disini\nSelamat! ESP32/ESP8266 Siap Diprogram! Sekarang kamu sudah siap mengeksplorasi dunia IoT, sensor, WiFi, dan Bluetooth jika menggunakan ESP32 di Arduino IDE. ğŸ‰ğŸ‰ğŸ‰.\n","permalink":"https://catatandeveloper.id/install-esp32-esp8266-di-arduino-ide/","title":"Install Esp32/Esp8266 Di Arduino Ide"},{"content":" Windows mod (modifikasi) adalah versi tidak resmi dari sistem operasi Microsoft Windows yang telah diubah atau dimodifikasi oleh pihak ketiga (bukan Microsoft). Modifikasi ini dilakukan untuk menyesuaikan Windows dengan kebutuhan tertentu. Biasanya untuk performa lebih cepat, ukuran lebih ringan, atau tampilan yang berbeda.\nApa yang Dimodifikasi? Windows mod bisa mencakup perubahan seperti:\nJenis Modifikasi Contoh ğŸ§¹ Menghapus fitur Cortana, OneDrive, Windows Defender, Microsoft Store âš™ï¸ Optimasi sistem Tweak registry, mematikan service latar belakang, optimasi CPU/GPU ğŸ¨ Tampilan Tema custom, ikon, wallpaper, taskbar transparan ğŸ’» Ukuran Instalasi lebih kecil dan ringan ğŸ”’ Privasi Mematikan Telemetry dan pelacakan Microsoft ğŸ”“ Aktivasi\tPre-activated dengan aktivator ilegal (berisiko) Tujuan Penggunaan Windows Mod Kelebihan Penjelasan ğŸ”‹ Ringan dan Cepat Banyak fitur bawaan yang dihapus, membuat Windows lebih ringan dan responsif ğŸ® Optimal untuk Gaming Minim proses latar belakang, FPS lebih stabil, dan latency lebih rendah ğŸ§¹ Bebas Bloatware Tidak ada aplikasi bawaan seperti Xbox, Skype, Cortana, dll yang memakan resource ğŸ”’ Privasi Lebih Baik\tBanyak versi mematikan Telemetry dan pelacakan dari Microsoft ğŸ’¾ Ukuran Instalasi Kecil File ISO dan kebutuhan penyimpanan lebih kecil, cocok untuk SSD/HDD kapasitas rendah âš™ï¸ Customisasi Mudah Lebih bebas dalam mengganti tema, ikon, tampilan UI, dan konfigurasi sistem ğŸ§  Optimasi Performa Banyak tweak pada registry dan service untuk mempercepat kinerja sistem ğŸ–¥ï¸ Cocok untuk PC Lama Bisa berjalan lancar di komputer dengan RAM 2â€“4 GB atau prosesor jadul Contoh Windows 10 Mod 1. GhostSpectre Windows 10\nâœ… Fokus: Performa tinggi, ringan, bebas bloatware.\nğŸ–¥ï¸ Cocok untuk: Gaming, PC spek rendah.\nğŸ” Varian: SuperLite, Compact, dengan atau tanpa Defender.\nğŸ› ï¸ Fitur: Telemetry dimatikan, Cortana dihapus, UI tetap modern\nğŸŒ URL resmi: GhostSpectre\n2. Atlas OS\nâœ… Fokus: Optimalisasi untuk Gaming Esports dan performa.\nğŸ–¥ï¸ Cocok untuk: Gamer kompetitif \u0026amp; pengguna power-user.\nğŸ” Ciri khas: Versi debloat dari Windows 10/11, tapi masih menjaga kestabilan sistem.\nğŸŒ URL resmi: AtlasOS\n3. Phoenix Lite OS\nâœ… Fokus: Visual keren + performa tinggi.\nğŸ–¥ï¸ Cocok untuk: Pengguna yang ingin UI cantik tapi tetap ringan.\nğŸ” Ciri khas: Tema modifikasi, ikon custom, dan UI yang menyerupai Windows 11.\nğŸŒ URL resmi: PhoenixOS\nRisiko dan Kekurangan Windows Mod Resiko Penjelasan âŒ Tidak legal Tidak sesuai lisensi Microsoft ğŸ” Keamanan lemah\tBisa disusupi malware/backdoor âš™ï¸ Update rusak\tTidak bisa update atau error ğŸ’¥ Tidak stabil\tProgram atau driver bisa tidak berjalan ğŸ“¦ Dukungan terbatas Sulit diperbaiki jika rusak, karena tidak resmi âš ï¸ Windows modded cocok untuk pengguna yang paham risiko dan butuh sistem ringan, terutama untuk gaming atau perangkat lama. Namun tidak disarankan untuk pemakaian utama, profesional, atau penggunaan jangka panjang karena alasan keamanan dan legalitas. Kalau kamu ingin Windows yang ringan tapi tetap aman, lebih baik pertimbangkan: Windows 10 LTSC (versi resmi yang minim bloatware) atau gunakan Windows asli lalu lakukan optimasi manual.\n","permalink":"https://catatandeveloper.id/windows-mod/","title":"Windows Mod, Bahaya atau Solusi?"},{"content":" Masih bingung gimana si caranya deploy Go di VPS?. kali ini kita akan membahas secara detail dan mudah dipahami, untuk menambahkan domain ke VPS dan mengamankannya dengan SSL menggunakan Let\u0026rsquo;s Encrypt, serta mengatur reverse proxy menggunakan Nginx untuk aplikasi Go (Golang), ikuti langkah-langkah berikut:\nArahkan Domain ke IP VPS Pastikan domain kamu sudah diarahkan ke IP publik VPS:\nLogin ke pengelola DNS domain (misalnya Cloudflare, Niagahoster, dll). Tambah record A: Type: A Name: @ Value: \u0026lt;IP VPS Kamu\u0026gt; TTL: Auto (Tambahkan juga record www jika ingin mendukung www.domain.com). tunggu beberapa menit dan lakukan ping domain.com untuk memastikan domain resolve ke IP VPS. Install Nginx di VPS login vps dengan SSH dan ketikan pada terminal di vps kmu\n$ sudo apt update $ sudo apt install nginx -y check statu nginx\n$ sudo systemctl status nginx Install Certbot untuk Let\u0026rsquo;s Encrypt $ sudo apt install certbot python3-certbot-nginx -y Tambah Konfigurasi Domain di Nginx Buat file konfigurasi domain di /etc/nginx/sites-available/namadomain.com:\n$ sudo nano /etc/nginx/sites-available/namadomain.com Isi dengan:\nserver { listen 80; server_name namadomain.com www.namadomain.com; location / { proxy_pass http://localhost:8080; # Port aplikasi Go kamu proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection \u0026#39;upgrade\u0026#39;; proxy_set_header Host $host; proxy_cache_bypass $http_upgrade; } } Lalu aktifkan konfigurasi dengan membuat symlink:\n$ sudo ln -s /etc/nginx/sites-available/namadomain.com /etc/nginx/sites-enabled/ Cek konfigurasi:\n$ sudo nginx -t pastikan semua ok dan tidak failed ya. kemudian restart nginx\n$ sudo systemctl restart nginx Generate SSL dengan Let\u0026rsquo;s Encrypt $ sudo certbot --nginx -d namadomain.com -d www.namadomain.com Ikuti proses interaktif, pilih redirect HTTP to HTTPS saat diminta.\nCek Otomatisasi Perpanjangan SSL Let\u0026rsquo;s Encrypt hanya berlaku 90 hari, tapi bisa diperpanjang otomatis:\n$ sudo certbot renew --dry-run jika ingin hanya melakukannya pada domain tertentu\n$ sudo certbot certonly --nginx --dry-run --cert-name namadomain.id Jalankan Aplikasi Go untuk kali ini kita gunakan code yang sederhana saja ya, codenya seperti dibawah ini\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;net/http\u0026#34; ) func handler(w http.ResponseWriter, r *http.Request) { fmt.Fprintln(w, \u0026#34;Hello, World\u0026#34;) } func main() { http.HandleFunc(\u0026#34;/\u0026#34;, handler) fmt.Println(\u0026#34;Server running on http://localhost:8080\u0026#34;) http.ListenAndServe(\u0026#34;:8080\u0026#34;, nil) } simpan dengan nama main.go dan jalankan dengan cara seperti biasa\n$ go run main.go Selesai dengan melakukan cara seperti ini kamu akan menjalankan program go dengan domain yang sudah kamu siapkan, baca artikel menarik lainnya di web kami.\nHappy Hacking ğŸš€ğŸš€ğŸš€\n","permalink":"https://catatandeveloper.id/cara-deploy-golang-di-vps/","title":"Cara Deploy Golang Dengan Domain Di VPS"},{"content":" Secara default, akun gratis di Vercel hanya bisa melakukan deploy dari repository yang dimiliki sendiri. Fitur deploy dari repository eksternal (yang bukan milik kita) hanya tersedia di akun berbayar. Namun, ada solusi cerdas untuk mengakalinya: kita bisa mirror isi repository eksternal ke repository milik sendiri, lalu melakukan deploy ke Vercel dari repository milik sendiri tersebut.\nArtikel ini akan membahas cara mengatur GitLab CI/CD agar otomatis menyalin isi dari repository eksternal ke repository pribadi, yang sudah terhubung dan terdeploy dengan Vercel.\nSyarat GitLab Kamu memiliki akses sebagai Maintainer pada repository eksternal tersebut (agar bisa menambahkan CI/CD Variable).\nKamu sudah membuat repository di akun GitLab sendiri.\nBuat Personal Access Token di GitLab Buka GitLab, lalu ke menu Preferences \u0026gt; Access Tokens, atau bisa akses langsung via personal_access_tokens.\nBuat token baru dengan scope berikut:\nâœ… api âœ… read_repository âœ… write_repository Simpan token tersebut di tempat aman karena hanya ditampilkan sekali saja saat baru saja membuatnya. Tambahkan CI/CD Variable pada Repo Eksternal Buka repository eksternal, misalnya https://gitlab.com/akun_teman_atau_group/nama_repo.\nMasuk ke Settings \u0026gt; CI/CD \u0026gt; Variables, lalu tambahkan variable:\nKey: TARGET_REPO_URL Value: https://oauth2:\u0026lt;token\u0026gt;@gitlab.com/\u0026lt;nama_akun_gitlab_kamu\u0026gt;/\u0026lt;repo\u0026gt;.git Penjelasan:\nGanti \u0026lt;token\u0026gt; dengan token dari langkah 1 Ganti \u0026lt;nama_akun_gitlab_kamu\u0026gt; dengan username GitLab kamu Ganti \u0026lt;repo\u0026gt; dengan nama repository milik sendiri Pada section Visibility, pilih Masked âœ… Pada section Flags, jangan centang Protect variable âŒ Contoh: Buat .gitlab-ci.yml pada Repo Eksternal Berikut adalah contoh isi file .gitlab-ci.yml :\nstages: - sync sync_to_target: stage: sync only: refs: - main script: - git config --global user.name \u0026#34;GitLab CI\u0026#34; - git config --global user.email \u0026#34;ci@example.com\u0026#34; - git clone \u0026#34;$TARGET_REPO_URL\u0026#34; target-repo - cd target-repo - | if git ls-remote --exit-code --heads origin main; then git checkout main else git checkout --orphan main fi - cd .. - find . -mindepth 1 -maxdepth 1 ! -name \u0026#39;.git\u0026#39; ! -name \u0026#39;target-repo\u0026#39; -exec cp -r {} target-repo/ \\; - cd target-repo - git add . - git commit -m \u0026#34;Auto mirror\u0026#34; || echo \u0026#34;Nothing to commit\u0026#34; - git push origin main Pada contoh ini menggunakan branch main, kamu bisa menganti sesuai dengan branch dari repository eksternal yang ingin dilakukan mirroring. Misal branch sumber ingin diubah dari branch dev, maka cukup ubah bagian only \u0026gt; refs menjadi :\nonly: refs: - dev Lakukan Perubahan pada Repo Eksternal Coba lakukan perubahan, lalu push commit ke repository eksternal. Akan terlihat proses dari CI/CD pada repository eksternal, jika proses sudah selesai, maka akan berubah menjadi centang.\nDeploy Repo Pribadi ke Vercel Pada dasbor Vercel, buat project baru, caranya :\nTekan tombol Add New, pilih opsi Project.\nPada Import Git Repository, pastikan GitLab sudah terhubung ke Vercel, cari repository yang tadi dibuat.\nSelesaikan proses pengaturan project hingga deployment berhasil.\nHasil Akhir Dengan konfigurasi di atas, setiap kali ada perubahan di branch yang telah ditentukan pada repository eksternal, maka akan terjadi dua proses, yakni :\nGitLab CI/CD akan otomatis menyalin seluruh file dari repository eksternal (sesuai branch yang telah ditentukan) ke repository milik sendiri pada branch main.\nVercel akan menangkap perubahan pada repository milik sendiri dan melakukan auto-deploy.\n","permalink":"https://catatandeveloper.id/deploy-repo-gitlab-eksternal-ke-vercel-dengan-akun-gratis/","title":"Deploy Repo GitLab Eksternal Ke Vercel dengan Akun Gratis"},{"content":" Modul GPS NEO-6M/NEO-7M adalah salah satu GPS receiver paling populer yang sering digunakan pada proyek Arduino atau ESP32. Dalam tutorial ini, kita akan belajar cara membaca data lokasi dari modul GPS menggunakan ESP32 dan library TinyGPS++.\nPerlengkapan yang Dibutuhkan ESP32 Board (contoh: ESP32 DevKit v1) Modul GPS NEO-6M Kabel jumper Software Arduino IDE Wiring ESP32 ke Modul GPS NEO Hubungkan pin modul GPS ke ESP32 sebagai berikut: GPS ESP32 VCC 3.3v GND GND TX GPIO16 (RXD2) RX GPIO17 (TXD2) Catatan: GPS TX â†’ ESP32 RX, GPS RX â†’ ESP32 TX (cross connection)\nInstalasi Library TinyGPS++ Buka Arduino IDE\nMasuk ke Tools \u0026gt; Manage Libraries Cari TinyGPSPlus(Mikal Hart) dan klik Install Kode Lengkap #include \u0026lt;TinyGPS++.h\u0026gt; // Define the RX and TX pins for Serial 2 #define RXD2 16 #define TXD2 17 #define GPS_BAUD 9600 // The TinyGPS++ object TinyGPSPlus gps; // Create an instance of the HardwareSerial class for Serial 2 HardwareSerial gpsSerial(2); void setup() { // Serial Monitor Serial.begin(115200); // Start Serial 2 with the defined RX and TX pins and a baud rate of 9600 gpsSerial.begin(GPS_BAUD, SERIAL_8N1, RXD2, TXD2); Serial.println(\u0026#34;Serial 2 started at 9600 baud rate\u0026#34;); } void loop() { // This sketch displays information every time a new sentence is correctly encoded. unsigned long start = millis(); while (millis() - start \u0026lt; 1000) { while (gpsSerial.available() \u0026gt; 0) { gps.encode(gpsSerial.read()); } if (gps.location.isUpdated()) { Serial.print(\u0026#34;LAT: \u0026#34;); Serial.println(gps.location.lat(), 6); Serial.print(\u0026#34;LONG: \u0026#34;); Serial.println(gps.location.lng(), 6); Serial.print(\u0026#34;SPEED (km/h) = \u0026#34;); Serial.println(gps.speed.kmph()); Serial.print(\u0026#34;ALT (min)= \u0026#34;); Serial.println(gps.altitude.meters()); Serial.print(\u0026#34;HDOP = \u0026#34;); Serial.println(gps.hdop.value() / 100.0); Serial.print(\u0026#34;Satellites = \u0026#34;); Serial.println(gps.satellites.value()); Serial.print(\u0026#34;Time in UTC: \u0026#34;); Serial.println(String(gps.date.year()) + \u0026#34;/\u0026#34; + String(gps.date.month()) + \u0026#34;/\u0026#34; + String(gps.date.day()) + \u0026#34;,\u0026#34; + String(gps.time.hour()) + \u0026#34;:\u0026#34; + String(gps.time.minute()) + \u0026#34;:\u0026#34; + String(gps.time.second())); Serial.println(\u0026#34;\u0026#34;); } } } Penjelasan Fungsi Penting gpsSerial.begin(\u0026hellip;)\nMembuka serial komunikasi kedua (UART2) antara ESP32 dan modul GPS.\ngps.encode(\u0026hellip;)\nMembaca dan mengolah data NMEA yang dikirim modul GPS.\ngps.location.lat() / gps.location.lng()\nMengambil data koordinat latitude dan longitude.\ngps.speed.kmph()\nKecepatan dalam kilometer per jam.\ngps.hdop.value()\nHorizontal dilution of precision, semakin kecil nilainya, semakin akurat.\ngps.satellites.value()\nJumlah satelit yang terdeteksi.\nOutput Contoh di Serial Monitor Serial 2 started at 9600 baud rate LAT: -7.797068 LONG: 110.370529 SPEED (km/h) = 0.00 ALT (min)= 145.80 HDOP = 0.90 Satellites = 8 Time in UTC: 2025/6/2,08:12:45 Tips Tambahan Pastikan modul GPS berada di tempat terbuka agar bisa menangkap sinyal satelit. Lampu LED pada modul GPS biasanya akan berkedip saat telah berhasil lock satelit. Untuk pemetaan lebih lanjut, data ini bisa dikirim ke Google Maps, Firebase, atau disimpan ke SD Card. Semoga tutorial ini bermanfaat bagi kamu yang ingin mulai belajar membaca data lokasi GPS dengan ESP32. Jangan lupa untuk menyimpan dan membagikan halaman ini jika kamu merasa terbantu! ğŸš€\n","permalink":"https://catatandeveloper.id/cara-mengakses-gps-module-neo-menggunakan-esp32/","title":"Cara Mengakses Gps Module Neo-6m/Neo-7m Menggunakan Esp32"},{"content":" Pernah kebayang gimana caranya update firmware ESP32 tanpa harus colok kabel USB lagi? ğŸ¤¯ Yup, sekarang kamu bisa update firmware secara OTA (Over-the-Air) lewat jaringan WiFi. Cocok banget buat proyek IoT yang susah dijangkau atau sudah dipasang permanen di lapangan.\nDi artikel ini, aku akan membagikan program sederhana yang memungkinkan perangkat ESP32 kamu mengecek versi firmware terbaru dan memperbaruinya secara otomatis jika diperlukan.\nApa itu OTA (Over-the-Air) Update? OTA adalah proses memperbarui firmware microcontroller lewat jaringan, tanpa perlu koneksi fisik. Dalam dunia IoT, fitur ini sangat penting karena kita bisa melakukan perawatan jarak jauh, hemat waktu dan tenaga!\nAlur Percobaan perhatikan setiap langkah dengan teliti ya, kita akan menggunakan localhost sebagai percobaan.\nUpload Program Lengkap Dibawah ke ESP32 upload program seperti biasa ke esp32, tunggu sampai selesai\nExport Program BIN klik di Sketch -\u0026gt; Export Compiled Binary Copy BIN ke Server dan buat file version silahkan copy file.bin hasil dari yang sudah kita export ke folder server kita. dan juga buat file dengan nama version.txt yang berisi versi dari program kita seperti dibawah ini Kode Lengkap #include \u0026lt;WiFi.h\u0026gt; #include \u0026lt;HTTPClient.h\u0026gt; #include \u0026lt;Update.h\u0026gt; const char* ssid = \u0026#34;host\u0026#34;; const char* password = \u0026#34;password\u0026#34;; const char* ota_server = \u0026#34;http://ip/\u0026#34;; String ota_bin = String(ota_server) + \u0026#34;ota/ota.ino.bin\u0026#34;; String ota_version = String(ota_server) +\u0026#34;ota/version.txt\u0026#34;; #define FW_VERSION \u0026#34;0.0.1\u0026#34; void setup() { Serial.begin(115200); // Connect to Wi-Fi WiFi.begin(ssid, password); while (WiFi.status() != WL_CONNECTED) { delay(1000); Serial.println(\u0026#34;Connecting to WiFi...\u0026#34;); } Serial.println(\u0026#34;Connected to WiFi\u0026#34;); } void loop() { Serial.println(\u0026#34;Checking for update...\u0026#34;); String latest_version = fetch_latest_version(ota_version); if (is_new_version_available(FW_VERSION, latest_version)) { Serial.printf(\u0026#34;New version available: %s\\n\u0026#34;, latest_version.c_str()); perform_ota_update(); // lanjut update OTA } else { Serial.println(\u0026#34;Firmware is up to date.\u0026#34;); } Serial.print(\u0026#34;version -\u0026gt; \u0026#34;); Serial.println(FW_VERSION); delay(5000); } bool is_new_version_available(const String\u0026amp; current_version, const String\u0026amp; new_version) { return current_version != new_version; // bisa buat lebih kompleks untuk server } String fetch_latest_version(const String\u0026amp; url) { HTTPClient http; http.begin(url); int httpCode = http.GET(); if (httpCode == HTTP_CODE_OK) { String version = http.getString(); version.trim(); http.end(); return version; } http.end(); return \u0026#34;\u0026#34;; } void perform_ota_update() { Serial.println(\u0026#34;Starting OTA update...\u0026#34;); HTTPClient http; http.begin(ota_bin); // Start the update process if (Update.begin(UPDATE_SIZE_UNKNOWN)) { Serial.println(\u0026#34;Downloading...\u0026#34;); // Start the download int httpCode = http.GET(); if (httpCode == HTTP_CODE_OK) { WiFiClient\u0026amp; stream = http.getStream(); uint8_t buffer[1024]; int bytesRead; // Write the stream to the Update library in chunks while ((bytesRead = stream.readBytes(buffer, sizeof(buffer))) \u0026gt; 0) { if (Update.write(buffer, bytesRead) != bytesRead) { Serial.println(\u0026#34;Error during OTA update. Please try again.\u0026#34;); Update.end(false); // false parameter indicates a failed update return; } } // End the update process if (Update.end(true)) { Serial.println(\u0026#34;OTA update complete. Rebooting...\u0026#34;); ESP.restart(); } else { Serial.println(\u0026#34;Error during OTA update. Please try again.\u0026#34;); Update.end(false); // false parameter indicates a failed update } } else { Serial.println(\u0026#34;Failed to download firmware.\u0026#34;); Update.end(false); // false parameter indicates a failed update } } else { Serial.println(\u0026#34;Failed to start OTA update.\u0026#34;); } // End HTTP client http.end(); } Konsep Program Program ini bekerja dengan cara:\nTerhubung ke WiFi Mengecek versi firmware terbaru di server Jika ada versi lebih baru dari firmware saat ini, ESP32 akan: Mengunduh file .bin Melakukan update Restart otomatis Inisialisasi Path Server dan Version const char* ota_server = \u0026#34;http://ip/\u0026#34;; String ota_bin = String(ota_server) + \u0026#34;ota/ota.ino.bin\u0026#34;; String ota_version = String(ota_server) +\u0026#34;ota/version.txt\u0026#34;; #define FW_VERSION \u0026#34;0.0.1\u0026#34; ESP32 akan membandingkan FW_VERSION lokal dengan isi dari version.txt di server.\nJika ada perbedaan versi, maka fungsi perform_ota_update() akan dijalankan untuk mengunduh firmware dan memperbarui ESP32 secara langsung.\nMengecek Versi Terbaru String fetch_latest_version(const String\u0026amp; url) { HTTPClient http; http.begin(url); int httpCode = http.GET(); if (httpCode == HTTP_CODE_OK) { String version = http.getString(); version.trim(); http.end(); return version; } http.end(); return \u0026#34;\u0026#34;; } Fungsi ini membaca versi terbaru dari file teks di server.\nUpdate Firmware if (Update.begin(UPDATE_SIZE_UNKNOWN)) { // Streaming data dan menulis ke memori flash } Firmware baru diunduh menggunakan HTTP dan ditulis ke flash memory menggunakan library Update.\nJika semua sukses, ESP32 akan restart dan menjalankan firmware baru.\nPenutup Dengan OTA, kamu bisa:\nMenghemat waktu Menghindari bongkar pasang alat Menjadikan sistem IoT kamu lebih profesional dan scalable Kalau kamu lagi ngerjain proyek ESP32, fitur ini WAJIB dicoba!. selamat mencoba! ğŸš€ğŸš€ğŸš€\n","permalink":"https://catatandeveloper.id/ota-update-firmware-otomatis-lewat-wifi-dengan-mudah/","title":"OTA, Update Firmware Otomatis Lewat Wifi Dengan Mudah"},{"content":" Saat membuat file ZIP di macOS, sering kali file tersembunyi seperti .DS_Store ikut terarsipkan secara otomatis. File .DS_Store adalah file metadata yang digunakan oleh macOS untuk menyimpan informasi tampilan folder, seperti posisi ikon atau pilihan tampilan. Meskipun berguna di sistem Mac, file ini bisa menjadi gangguan saat file ZIP dibuka di sistem operasi lain seperti Windows atau Linux. Dalam beberapa kasus, keberadaan .DS_Store juga dianggap sebagai \u0026ldquo;sampah\u0026rdquo; yang tidak relevan dan bisa menyebabkan kebingungan atau dianggap sebagai file asing.\nUntuk itu, penting untuk membuat file ZIP yang bersih dan bebas dari .DS_Store, terutama jika file tersebut akan dibagikan ke tim lintas platform atau digunakan di lingkungan produksi.\nBerikut adalah langkah-langkah membuat file ZIP melalui terminal di macOS dengan pengecualian file .DS_Store:\n1. Buka Terminal dan Arahkan ke Folder yang Ingin Diarsipkan Langkah pertama adalah masuk ke direktori tempat folder atau file yang ingin kamu kompres berada. Gunakan perintah cd (change directory):\n$ cd path/ke/folder/induk Contoh:\n$ cd ~/Documents/Project Tips: Kamu bisa lakukan drag \u0026amp; drop folder melalui Finder ke terminal agar tidak repot menulis path direktori folder. Tetap diawali perintah cd lalu spasi, lalu drag folder dari Finder.\nPastikan kamu berada satu level di atas folder atau file yang ingin di-zip.\n2. Jalankan Perintah zip Gunakan perintah dengan format berikut:\n$ zip -r -X namafile.zip namafolder -x \u0026#34;*.DS_Store\u0026#34; Penjelasan:\nzip: perintah untuk membuat file ZIP. -r: recursive, menyertakan semua file dan subfolder. -X: menghapus metadata sistem macOS dari file ZIP. namafile.zip: nama file ZIP yang akan dibuat. namafolder: nama folder atau file yang ingin dikompres. -x \u0026quot;*.DS_Store\u0026quot;: mengecualikan semua file .DS_Store. Contoh lengkap: $ zip -r -X proyeksaya.zip folderku -x \u0026#34;*.DS_Store\u0026#34;\nDengan langkah ini, kamu dapat menghasilkan file ZIP yang lebih bersih, ringan, dan aman digunakan di berbagai sistem operasi tanpa membawa file internal milik macOS yang tidak diperlukan. Selamat mencoba ğŸš€ğŸš€\n","permalink":"https://catatandeveloper.id/buat-file-zip-di-macos-tanpa-ds-store/","title":"Buat File Zip Di MacOS Tanpa .DS_Store"},{"content":" Autentikasi adalah salah satu fitur paling penting dalam aplikasi web modern. Laravel, sebagai salah satu framework PHP terbaik, menyediakan sistem autentikasi bawaan yang sangat powerful dan mudah digunakan.\nPada blog kali ini, kita akan membahas:\nApa itu Laravel Auth Instalasi Laravel Cara mengaktifkan Auth di Laravel Menyesuaikan tampilan dan fitur login Apa Itu Laravel Auth? Laravel Auth adalah sistem autentikasi default yang disediakan Laravel untuk menangani:\nRegistrasi pengguna Login \u0026amp; logout Proteksi halaman (middleware auth) Reset password Laravel sejak versi 6+ memisahkan sistem ini ke dalam paket bernama Laravel Breeze, Jetstream, atau Fortify, tergantung kebutuhan Anda. Instalasi Laravel $ php -v Jika belum ada, kamu bisa install PHP dulu, jika menggunakan windows kamu bisa pakai XAMPP atau Laragon:\n$ sudo apt update $ sudo apt install php-cli Install composser, jika menggunakan windows bisa download lewat getcomposer.org.\n$ sudo apt install unzip curl $ curl -sS https://getcomposer.org/installer -o composer-setup.php $ HASH=$(curl -sS https://composer.github.io/installer.sig) $ php -r \u0026#34;if (hash_file(\u0026#39;sha384\u0026#39;, \u0026#39;composer-setup.php\u0026#39;) === \u0026#39;$HASH\u0026#39;) { echo \u0026#39;Installer verified\u0026#39;; } else { echo \u0026#39;Installer corrupt\u0026#39;; unlink(\u0026#39;composer-setup.php\u0026#39;); } echo PHP_EOL;\u0026#34; $ sudo php composer-setup.php --install-dir=/usr/local/bin --filename=composer $ composer --version Install laravel\n$ composer create-project \u0026#34;laravel/laravel:^12.0\u0026#34; example-app Setup Databases Buka phpmyadmin dan buat database dengan nama \u0026ldquo;laravel_auth\u0026rdquo; seperti dibawah Ubah settingan pada .env DB_CONNECTION=mysql DB_HOST=127.0.0.1 DB_PORT=3306 DB_DATABASE=laravel_auth DB_USERNAME=root DB_PASSWORD=\nKoneksikan database dengan laravel dengan cara masuk dalam direktori project dan ketikan: $ php artisan migrate\nCara mengaktifkan Auth di Laravel Instal Laravel Breeze (sistem auth ringan dan sederhana)\n$ composer require laravel/breeze --dev $ php artisan breeze:install $ npm install \u0026amp;\u0026amp; npm run build Setelah proses ini selesai, Laravel sudah menyediakan halaman:\n/login /register /dashboard (halaman yang dilindungi middleware) ğŸ’¡ Gunakan $ php artisan serve untuk melihat hasilnya di http://localhost:8000.\nHasilnya seperti berikut: Menyesuaikan Tampilan Login Laravel Breeze menggunakan Blade dan Tailwind CSS. Untuk mengubah tampilan:\nBuka file resources/views/auth/login.blade.php Sesuaikan HTML, CSS, dan form sesuai kebutuhan Anda Contoh: menambahkan logo atau mengubah warna tombol login. Penutup Dengan Laravel Auth, Anda tidak perlu membuat sistem login dari nol. Laravel menyediakan semua fitur dasar, tinggal Anda sesuaikan dan perkuat keamanannya.\nSemoga tulisan ini bermanfaat bagi Anda yang sedang membangun aplikasi Laravel dengan fitur autentikasi! ğŸš€\n","permalink":"https://catatandeveloper.id/cara-gampang-auth-laravel/","title":"Cara Gampang Auth Laravel"},{"content":" Button di micro-controller berperan sangatlah penting, dengan menggunakan button kita bisa membuat berbagai konfigurasi manual seperti start/stop, settingan parameter, bahkah kalibarasi nilai dan menu-menu menarik lainnya.\ndalam tutorial kali ini kita akan membahas cara akses button menggunakan 2 cara yaitu pullup/pulldown resistor secara eksternal dan pullup internal dari arduino sendiri dengan sederhana.\nPull-up Resistor Eksternal pullup itu berarti resistor berada pada tegangan dan pin arduino dan membuat button ketika di tekan dia bernilai LOW, sedangkan jika di lepas maka bernilai HIGH const int buttonPin = 2; void setup() { pinMode(buttonPin, INPUT); Serial.begin(9600); } void loop() { if(digitalRead(buttonPin) == LOW) Serial.println(\u0026#34;push\u0026#34;); } Pull-down Resistor Eksternal pulldown itu berarti resistor berada pada ground dan pin arduino dan membuat button ketika di tekan dia bernilai HIGH, sedangkan jika di lepas maka bernilai LOW const int buttonPin = 2; void setup() { pinMode(buttonPin, INPUT); Serial.begin(9600); } void loop() { if(digitalRead(buttonPin) == HIGH) Serial.println(\u0026#34;push\u0026#34;); } Pull-up Internal Arduino pullup internal memungkinkan kita menggunakan resistor di internal arduino, sehinggal kita tidak perlu menambahkan resistor lagi, sehingga rangkaian lebih sederhana. const int buttonPin = 2; void setup() { pinMode(buttonPin, INPUT_PULLUP); Serial.begin(9600); } void loop() { if(digitalRead(buttonPin) == LOW) Serial.println(\u0026#34;push\u0026#34;); } Memanfaatkan library dengan memanfaatkan library kita akan lebih mudah melakukan konfigurasi button karena tidak terkedala dengan kondisi yang terus menerus terpenuhi.\ndownload library di github huros-button masukan dalam library, bisa melalui add zip atau ekstrak manual di folder document/arduino/library gunakan program example dan ubah sedikit sesuai kebutuhan button #include \u0026lt;HurosButton.h\u0026gt; #define BTN_PIN1 2 HurosButton btn1; void setup() { btn1.Init(BTN_PIN1, INPUT_PULLUP); Serial.begin(9600); } void loop() { btn1.Run(); if(btn1.IsPressed()){ Serial.println(\u0026#34;pin 1 pressed\u0026#34;); } if(btn1.IsRelease()){ Serial.println(\u0026#34;pin 1 release\u0026#34;); } } dengan memanfaatkan library diatas, kamu dapat membuat kondisi terpenuhi hanya ketika sudah di lepas atau saat tertekan saja. Selamat kamu sudah belajar cara mengakses button, semoga bermanfaat ğŸ‰ğŸ‰ğŸ‰.\n","permalink":"https://catatandeveloper.id/cara-mengakses-button/","title":"Cara Mengakses Button"},{"content":" Sebelum memulai, pastikan Git sudah terinstal di sistem kalian. Jika belum, silahkan ikuti tutorial Disini.\nMembuat Repositori Dalam pembuatan repository terdapat dua cara yaitu melakukan pembuatan dikomputer kita terlebih dulu atau melakukan cloning dari repository yang sudah ada cloud seperti github atau gitlab.\nInitisal repository - Git Init buat file index.html berisi program kita\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; pada terminal ketikan seperti berikut: $ git init .\ntanda (.) berarti semua file yang ada di directory, dengan kata lain membuat repository didirectory tersebut.\nmenambahkan ke git - Git Add Tambahkan file ke dalam Git dengan perintah berikut: $ git add .\nperintah ini akan menambahkan semua file yang ada dalam folder ke dalam staging area. Jika ingin menambahkan file tertentu, gunakan: $ git add namafile\nMenyimpan Perubahan - Git Commit Setelah file ditambahkan, simpan perubahan dengan perintah: $ git commit -m \u0026#34;Pesan commit pertama\u0026#34;\nPastikan pesan commit menjelaskan perubahan yang dilakukan.\nMelihat Log - Git Log (opsional) Untuk melihat history dari commitan, kamu bisa melakukan log seperti dibawah $ git log dan hasilnya seperti berikut: kamu juga bisa melakukan log sederhana untuk melihat daftar log lebih ringkas dengan cara: $ git log --oneline\nManambahkan remote - Git Remote buat repository terlebih dahulu di github atau gitlab kalian copy url pada ssh/https Tambahkan remote repository github atau gitlab kalian seperti dibawah: $ git remote add [nama remote] [url]\npenjelasan\nnama remote : dalah nama yang kalian berikan untuk repository tersebut, biasanya namanya adalah origin url : kalian bisa menggunakan https/ssh, https membutuhkan token sedangkan ssh membutuhkan konfigurasi diawal HTTPS kalian harus membuat token terlebih dahulu di git hosting kalian.\nkami mengambil contoh di github:\ngo to Setting-\u0026gt; Developer setting -\u0026gt; personal access token, create, copy dan save token di note.\nsimpan remote $ git remote add origin https://[TOKEN]@github.com/[REPO-OWNER]/[REPO-NAME]\ncara diatas akan memudahkan kamu, karena tidak perlu melakukan authorization password\n$ git remote add origin https://github.com/[REPO-OWNER]/[REPO-NAME] cara diatas membutuhkan password saat cloning, password diisi dengan token!.\nSSH kami menyarahkan untuk menggunakan ssh agar lebih mudah kedepannya, kalian bisa melakukan config seperti link berikut\nUpload ke git hosting - Git Push gunakan nama hosting tujuan dan branch tujuan untuk melakukan upload, $ git push [nama remote] [nama branch]\nby default remote adalah origin dan branch adalah master:\n$ git push origin master Cloning Repository - Git Clone jika kalian ingin melakukan cloning terhadap repository yang sudah ada kalian bisa menggunakan cloning sederhana seperti berikut:\n$ git clone [url] jika program menggunakan submodule kalian perlu menambahkan prefix seperti berikut. $ git clone [url] --recurse-submodules\nUpdate Repository - Git Pull bersihkan dahulu directory kalian sebelum pull agar tidak terjadi conflict, kalian bisa menggunakan reset $ git reset --hard HEAD\nkemuadian pull\n$ git pull [nama remote] [nama branch] Itulah langkah-langkah dasar untuk memulai repositori Git. Dengan memahami dasar-dasar ini, Kalian dapat mengelola kode dengan lebih baik menggunakan Git.ğŸš€ğŸš€ğŸš€\n","permalink":"https://catatandeveloper.id/memulai-git/","title":"Memulai Git"},{"content":" Bagi para developer, istilah \u0026ldquo;Git\u0026rdquo; dan \u0026ldquo;GitHub\u0026rdquo; sering digunakan secara bersamaan, tetapi sebenarnya keduanya adalah hal yang berbeda. Dalam artikel ini, kita akan membahas perbedaan antara Git dan GitHub, serta bagaimana keduanya bekerja sama dalam pengembangan perangkat lunak.\nApa Itu Git? Git adalah sistem kontrol versi (VCS - Version Control System) yang digunakan untuk melacak perubahan dalam kode sumber selama pengembangan perangkat lunak. Dengan Git, developer dapat:\nMenyimpan riwayat perubahan kode. Berkolaborasi dengan tim tanpa risiko kehilangan kode. Mengembalikan kode ke versi sebelumnya jika terjadi kesalahan. Fitur Utama Git Distribusi: Git bersifat terdistribusi, artinya setiap pengguna memiliki salinan penuh dari repositori. Branching dan Merging: Git memungkinkan pengembangan fitur secara paralel melalui sistem cabang (branch). Commit dan Revert: Setiap perubahan dapat disimpan sebagai commit dan bisa dikembalikan jika diperlukan. Apa Itu GitHub? GitHub adalah platform berbasis cloud yang menyediakan layanan hosting untuk repositori Git. Ini memungkinkan developer untuk menyimpan dan mengelola proyek Git mereka secara online, serta berkolaborasi dengan tim secara lebih efektif.\nFitur Utama GitHub Repositori Publik dan Privat: Menyimpan kode di cloud dengan opsi publik atau privat. Pull Request \u0026amp; Code Review: Memudahkan kerja sama tim dengan fitur ulasan kode. Issues \u0026amp; Project Management: Memungkinkan pencatatan bug dan manajemen tugas dalam proyek. Integrasi dengan CI/CD: Mendukung otomatisasi proses pengujian dan deployment. Perbedaan Utama Git vs GitHub Aspek Git Github Jenis Software Platform berbasis cloud Fungsi Mengelola versi kode secara lokal Menyediakan hosting repositori Git dan alat kolaborasi Penggunaan Dijalankan melalui command line atau GUI Digunakan melalui browser atau aplikasi GitHub Desktop Repositori Disimpan di komputer lokal Disimpan di server GitHub Bagaimana Git dan GitHub Bekerja Bersama? Meskipun Git dan GitHub berbeda, keduanya dapat bekerja bersama dalam pengembangan perangkat lunak. Berikut adalah langkah dasar penggunaannya:\nInstal Git di komputer Anda. Buat repositori lokal menggunakan perintah git init. Tambahkan file dan commit perubahan menggunakan git add dan git commit. Hubungkan repositori lokal dengan GitHub dengan git remote add origin \u0026lt;\u0026ldquo;URL-Repo\u0026rdquo;\u0026gt; . Dorong (push) perubahan ke GitHub dengan git push origin main(branch anda). Kesimpulan Git dan GitHub memiliki peran yang berbeda tetapi saling melengkapi. Git adalah sistem kontrol versi yang bekerja secara lokal, sementara GitHub adalah layanan berbasis cloud yang memungkinkan developer menyimpan dan berkolaborasi dalam pengembangan perangkat lunak. Dengan memahami perbedaan ini, Anda dapat mengoptimalkan penggunaan Git dan GitHub dalam proyek Anda.\nSemoga artikel ini membantu ya!. Selamat coding! ğŸš€ğŸš€ğŸš€\n","permalink":"https://catatandeveloper.id/gitvsgithub/","title":"Git vs Github"},{"content":" Git adalah salah satu sistem kontrol versi yang paling populer di kalangan developer. Dengan Git, Anda dapat melacak perubahan kode, bekerja secara kolaboratif, dan mengelola proyek dengan lebih baik. Dalam tutorial ini, kita akan membahas langkah-langkah instalasi Git di Windows, Linux dan Mac.\nInstalasi Git di Windows Download Git Kunjungi situs resmi Git for Windows. Klik tombol Download untuk mendapatkan installer. Instalasi klik 2 kali pada file git klik next pilih lokasi folder yang di inginkan kemundian klik next checklist additional icons on the desktop klik next, ini bersifat opsional klik next klik next klik next klik next klik next klik next pada tampilan diatas jika kalian memilih default git akan mengkonvert end of line atau \u0026ldquo;enter\u0026rdquo; menjadi CRLF, ini akan merusak file jika format sebelumnya berbeda, hal ini berpengaruh jika kamu berganti-ganti OS, contoh Windows ke Mac, karena secara default format file EOF mereka berbeda, jadi perlu di perhatikan untuk memilih opsi ini klik next klik next klik next klik next klik install Instalasi Git di Linux di linux kamu cukup mengetikan satu perintah seperti berikut:\n$ sudo apt install git Instalasi Git di macOS Gunakan Homebrew (Rekomendasi)\nJika belum memiliki Homebrew, instal terlebih dahulu dengan menjalankan perintah berikut di Terminal: $ /bin/bash -c \u0026#34;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\u0026#34;\nSetelah itu, instal Git menggunakan Homebrew: $ brew install git\nKonfigurasi Awal Git Setel Nama Pengguna: $ git config --global user.name \u0026#34;Nama Anda\u0026#34;\nSetel Email Pengguna: $ git config --global user.email \u0026#34;email@example.com\u0026#34;\nVerifikasi Konfigurasi $ git config --list\nKesimpulan Instalasi Git sangatlah mudah, baik di Windows, macOS, maupun Linux. Setelah instalasi selesai, pastikan untuk mengonfigurasi Git agar siap digunakan untuk proyek Anda.ğŸš€ğŸš€ğŸš€\n","permalink":"https://catatandeveloper.id/instalasi-git/","title":"Instalasi Git"},{"content":" Windows 10 adalah sistem operasi yang dikembangkan oleh Microsoft dan merupakan bagian dari keluarga Windows NT. Sistem operasi ini dirancang untuk mendukung berbagai jenis perangkat, seperti komputer desktop, laptop, tablet, hingga perangkat IoT (Internet of Things). Windows 10 pertama kali dirilis pada 29 Juli 2015 sebagai penerus dari Windows 8.1, dengan tujuan mengintegrasikan pengalaman pengguna di berbagai perangkat dan memperbaiki berbagai kekurangan dari versi sebelumnya.\nWindows 10 memiliki beberapa edisi yang dirancang untuk memenuhi kebutuhan pengguna yang berbeda, mulai dari pengguna individu hingga perusahaan besar. Berikut adalah penjelasan jenis-jenis Windows 10 dan perbedaannya:\nWindows 10 Home Target Pengguna: Pengguna rumahan dan individu. Fitur Utama: Fitur dasar seperti Cortana, Microsoft Edge, dan aplikasi bawaan seperti Mail, Calendar, Photos, dan lainnya. Dukungan untuk perangkat touchscreen. Game Mode dan integrasi Xbox. Kekurangan: Tidak memiliki fitur khusus untuk bisnis seperti BitLocker, Remote Desktop, atau Hyper-V. Windows 10 Pro Target Pengguna: Pengguna profesional dan bisnis kecil. Fitur Utama: Semua fitur Windows 10 Home. BitLocker: Fitur enkripsi untuk keamanan data. Remote Desktop: Mengakses komputer dari jarak jauh. Hyper-V: Virtualisasi bawaan untuk menjalankan mesin virtual. Dukungan untuk domain dan Group Policy Management. Kekurangan: Harga lebih mahal dibanding Windows 10 Home. Windows 10 Pro for Workstations Target Pengguna: Profesional dengan kebutuhan komputasi tinggi, seperti desainer grafis, insinyur, atau ilmuwan data. Fitur Utama: Semua fitur Windows 10 Pro. ReFS (Resilient File System): Sistem file untuk perlindungan data tingkat lanjut. Dukungan untuk perangkat keras dengan spesifikasi tinggi, termasuk prosesor server dan RAM lebih dari 2 TB. Transfer file lebih cepat dengan SMB Direct. Windows 10 Enterprise Target Pengguna: Perusahaan besar dengan kebutuhan keamanan dan manajemen tingkat tinggi. Fitur Utama: Semua fitur Windows 10 Pro. Windows Defender Advanced Threat Protection (ATP): Keamanan tingkat lanjut. AppLocker: Mengontrol aplikasi yang dapat dijalankan. DirectAccess: Akses jarak jauh aman ke jaringan perusahaan. Fitur pengelolaan IT seperti Windows To Go dan Group Policy tingkat lanjut. Kekurangan: Hanya tersedia melalui lisensi volume (volume licensing). Windows 10 Education Target Pengguna: Institusi pendidikan (sekolah, universitas). Fitur Utama: Mirip dengan Windows 10 Enterprise. Dirancang untuk mempermudah pengelolaan perangkat di lingkungan pendidikan. Tidak memiliki beberapa fitur bisnis seperti Cortana. Ketersediaan: Biasanya tersedia melalui program lisensi pendidikan. Windows 10 S / Windows 10 in S Mode Target Pengguna: Pengguna yang menginginkan keamanan dan performa ringan. Fitur Utama: Keamanan lebih tinggi karena hanya bisa menginstal aplikasi dari Microsoft Store. Performa optimal pada perangkat keras ringan. Cocok untuk pelajar atau pengguna dengan kebutuhan sederhana. Kekurangan: Sangat terbatas dalam hal kompatibilitas aplikasi. Penjelasan Fitur BitLocker: Fitur enkripsi untuk melindungi data pada perangkat Anda. Remote Desktop: Mengakses komputer Anda dari jarak jauh. Hyper-V: Virtualisasi untuk menjalankan sistem operasi lain dalam lingkungan virtual. ReFS (Resilient File System): Sistem file yang lebih tahan terhadap kerusakan data, cocok untuk server dan beban kerja berat. Windows Sandbox: Menjalankan aplikasi dalam lingkungan yang terisolasi. AppLocker: Membatasi aplikasi yang bisa diinstal atau dijalankan. Windows To Go: Membuat instalasi Windows portabel yang bisa dijalankan dari USB. Group Policy Management: Mengelola kebijakan untuk pengguna dalam jaringan perusahaan. Domain Join: Terhubung ke domain jaringan perusahaan. Microsoft Store Apps Saja: Pembatasan aplikasi hanya dari Microsoft Store untuk keamanan. Cara Cek Versi Windows Untuk mengecek versi Windows yang sedang Anda gunakan melalui Command Prompt (CMD), ikuti langkah-langkah berikut: Tekan Win + R, ketik winver, lalu tekan Enter. Jendela About Windows akan muncul, menampilkan versi Windows, build number, dan edisi.\nKesimpulan Home: Ideal untuk pengguna biasa dan aktivitas sehari-hari. Pro: Untuk profesional atau bisnis kecil yang membutuhkan fitur keamanan dan manajemen tambahan. Workstations: Untuk pengguna dengan kebutuhan komputasi tinggi, seperti pekerjaan berat atau workstation dengan spesifikasi tinggi. Enterprise: Untuk perusahaan besar dengan kebutuhan keamanan, manajemen, dan skala besar. Education: Dirancang untuk sekolah dan universitas, mirip dengan Enterprise tetapi lebih terfokus pada pendidikan. S Mode: Untuk pengguna ringan yang mengutamakan keamanan dan kinerja dengan pembatasan aplikasi hanya dari Microsoft Store. Jika Anda ingin lebih mendalami salah satu edisi, beri tahu saya!\n","permalink":"https://catatandeveloper.id/pengenalan-jenis-windows-10/","title":"Pengenalan Jenis Windows 10 Dan Perbedaannya"},{"content":" Penjelasan Git Git adalah sistem kontrol versi terdistribusi yang dirancang untuk membantu pengembang melacak perubahan dalam kode sumber mereka. Dengan Git, pengembang dapat bekerja secara bersamaan pada proyek yang sama tanpa khawatir akan kehilangan atau merusak pekerjaan satu sama lain. Git memungkinkan pengguna untuk menyimpan versi sebelumnya dari kode mereka sehingga mereka dapat kembali ke keadaan sebelumnya jika terjadi kesalahan.\nGit bersifat open-source dan gratis untuk digunakan. Dengan fitur seperti branch (percabangan), merge (penggabungan), dan commit, Git menjadi salah satu alat paling populer di dunia pengembangan perangkat lunak.\nSejarah Git Git pertama kali dibuat oleh Linus Torvalds pada tahun 2005. Linus Torvalds adalah pencipta kernel Linux, dan ia mengembangkan Git untuk memenuhi kebutuhan proyek Linux yang semakin kompleks. Sebelum menggunakan Git, komunitas Linux menggunakan sistem kontrol versi lain bernama BitKeeper. Namun, BitKeeper adalah perangkat lunak berpemilik, dan pada tahun 2005, hubungan antara komunitas Linux dan pengembang BitKeeper memburuk. Hal ini memaksa Linus Torvalds untuk mencari solusi alternatif.\nKarena tidak menemukan alat lain yang sesuai dengan kebutuhan proyek Linux, Linus memutuskan untuk membuat alatnya sendiri. Dalam waktu kurang dari dua minggu, ia menciptakan Git.\nNama git Torvalds menyindir dengan nada sarkastis tentang nama git (yang berarti \u0026ldquo;orang yang tidak menyenangkan\u0026rdquo;(unpleasant person) dalam bahasa gaul Inggris), Nama \u0026ldquo;Git\u0026rdquo; dipilih karena, menurut Linus:\n\u0026ldquo;I\u0026rsquo;m an egotistical bastard, and I name all my projects after myself. First \u0026lsquo;Linux\u0026rsquo;, now \u0026lsquo;git\u0026rsquo;.\nbahkan dalam man page git disebut \u0026ldquo;the stupid content tracker\u0026rdquo;, kamu bisa melihatnya dengan cara mengetikan di terminal:\n# man git Kenapa Git Dibuat? Git dirancang untuk mengatasi berbagai masalah yang dihadapi oleh sistem kontrol versi pada masanya, seperti:\nPerforma Tinggi: Git dibuat untuk menangani proyek dengan ukuran besar dan banyak kontribusi. Proses commit, branching, dan merging di Git sangat cepat dibandingkan dengan sistem lain yang ada saat itu.\nModel Terdistribusi: Tidak seperti sistem kontrol versi terpusat, Git memungkinkan setiap pengembang memiliki salinan lengkap dari repositori. Ini meningkatkan fleksibilitas dan memungkinkan pengembang bekerja secara offline.\nKeamanan Data: Git menggunakan model hash cryptographic SHA-1 untuk melacak perubahan dan memastikan integritas data. Setiap commit memiliki identifikasi unik yang membuatnya sulit untuk diubah tanpa terdeteksi.\nKolaborasi yang Lebih Mudah: Dengan fitur branching dan merging yang kuat, Git mempermudah pengembang untuk berkolaborasi pada proyek yang sama tanpa mengganggu pekerjaan satu sama lain.\nSifat Open-Source: Git dirilis sebagai perangkat lunak open-source, memungkinkan siapa saja untuk menggunakannya, memodifikasi, dan menyumbangkan perbaikan.\nKesimpulan Git adalah alat yang revolusioner dalam dunia pengembangan perangkat lunak. Dengan fitur-fitur canggih dan desain yang fleksibel, Git telah menjadi standar de facto untuk sistem kontrol versi. Sejarahnya yang berasal dari kebutuhan proyek Linux menunjukkan bagaimana sebuah alat yang dibuat untuk kebutuhan khusus dapat menjadi solusi global yang digunakan oleh jutaan pengembang di seluruh dunia.\n","permalink":"https://catatandeveloper.id/pengenalan-tentang-git/","title":"Pengenalan Tentang Git"},{"content":" Linux menggunakan struktur file berbasis hierarki yang dimulai dari root directory (/). Semua file dan direktori dalam sistem Linux berada di bawah root ini, termasuk perangkat keras yang terhubung. Berikut adalah penjelasan dari direktori utama yang sering ditemukan di sistem Linux, serta perbandingan dengan sistem operasi lain seperti Windows, FreeBSD, dan macOS.\nSejarah Struktur Direktori di Linux Struktur direktori Linux berasal dari sistem operasi UNIX, yang dikembangkan pada tahun 1970-an oleh Dennis Ritchie dan Ken Thompson di AT\u0026amp;T Bell Labs. UNIX dirancang untuk menjadi sistem operasi portabel, multi-user, dan multitasking. Salah satu inisiatif utamanya adalah menciptakan struktur file yang terorganisir secara hierarkis, dengan direktori root (/) sebagai pusatnya. Konsep ini sangat inovatif pada masanya karena memungkinkan berbagai perangkat keras dan file sistem dikelola dalam satu hierarki.\nPada tahun 1991, Linus Torvalds memulai proyek Linux sebagai implementasi kernel sistem operasi yang terinspirasi dari MINIX, sistem operasi turunan UNIX. Struktur direktori Linux mengadopsi banyak elemen dari UNIX karena kompatibilitas dan fleksibilitasnya. Standar hierarki ini terus berkembang dengan diperkenalkannya Filesystem Hierarchy Standard (FHS) yang mengatur tata letak direktori untuk memastikan konsistensi di berbagai distribusi Linux.\nPerbedaan dengan Windows, FreeBSD, dan macOS Windows: Tidak memiliki root directory tunggal seperti Linux. Sistem file Windows menggunakan drive letter (misalnya C:\\ atau D:). Struktur direktori Windows lebih sederhana tetapi kurang konsisten untuk perangkat keras dan aplikasi pihak ketiga.\nFreeBSD: Sangat mirip dengan Linux dalam hal struktur direktori karena keduanya berasal dari UNIX. Namun, FreeBSD sering memiliki beberapa direktori tambahan seperti /usr/local untuk aplikasi yang diinstal secara manual.\nmacOS: Juga berbasis UNIX, dengan struktur yang mirip dengan Linux dan FreeBSD. Namun, macOS memiliki direktori unik seperti /Applications untuk aplikasi pengguna dan /Library untuk file sistem dan pengguna.\nPenjelasan Direktori Utama di Linux Root Directory (/) / adalah direktori utama atau akar dari sistem file Linux. Semua direktori lain berada di bawah root ini. Root directory biasanya hanya dapat dimodifikasi oleh pengguna dengan hak akses superuser (root).\nWindows: Menggunakan drive utama seperti C:\\ sebagai akar sistem file. FreeBSD/macOS: Sama seperti Linux, menggunakan / sebagai root directory. /bin Berisi binary executable yang penting untuk sistem, seperti perintah dasar yang digunakan oleh semua pengguna, contohnya:\nls (melihat isi direktori) cp (menyalin file) mv (memindahkan file) Windows: Setara dengan direktori C:\\Windows\\System32 yang berisi file executable penting. FreeBSD/macOS: Mirip dengan Linux, menyimpan binary penting di /bin. /sbin Mirip dengan /bin, namun berisi binary yang digunakan oleh administrator sistem untuk tugas-tugas administrasi, seperti:\nfsck (memeriksa dan memperbaiki sistem file) reboot (me-restart sistem) Windows: Tugas administratif sering dijalankan melalui aplikasi GUI atau file di C:\\Windows\\System32. FreeBSD/macOS: Sama seperti Linux, berisi binary administratif di /sbin. /etc Direktori ini menyimpan file konfigurasi sistem. Contoh file di dalamnya:\n/etc/passwd (informasi tentang pengguna) /etc/hostname (nama host komputer) Windows: File konfigurasi tersebar di Registry atau file dalam C:\\Windows\\System32\\Config. FreeBSD/macOS: Sama seperti Linux, menyimpan konfigurasi di /etc. /home Setiap pengguna memiliki direktori rumah atau home directory di dalam /home, misalnya:\n/home/user1 /home/user2 Direktori ini berisi file pribadi pengguna seperti dokumen, pengaturan aplikasi, dan file konfigurasi pengguna.\nWindows: Setara dengan C:\\Users[username]. FreeBSD/macOS: Sama seperti Linux, menggunakan /home (FreeBSD) atau /Users (macOS). /root Direktori rumah untuk pengguna superuser (root). Berbeda dengan /home, direktori ini hanya diakses oleh administrator.\nWindows: Tidak memiliki direktori khusus untuk superuser. FreeBSD/macOS: Sama seperti Linux, memiliki direktori /root untuk superuser. /var Berisi file yang sering berubah, seperti:\nLog sistem di /var/log (misalnya /var/log/syslog untuk log sistem) Data aplikasi (misalnya database kecil, cache atau web) Windows: File sementara sering disimpan di C:\\Windows\\Temp atau di direktori aplikasi. FreeBSD/macOS: Sama seperti Linux, menyimpan file dinamis di /var. /usr Merupakan direktori untuk aplikasi dan file yang tidak penting untuk proses booting, termasuk:\n/usr/bin (binary tambahan untuk pengguna biasa) /usr/lib (library yang dibutuhkan oleh aplikasi di /usr/bin) Windows: Tidak ada direktori khusus seperti ini. Aplikasi pihak ketiga sering diinstal di C:\\Program Files. FreeBSD/macOS: Sama seperti Linux, menggunakan /usr. /lib dan /lib64 Berisi library yang digunakan oleh program di /bin dan /sbin. Contohnya adalah shared libraries yang berfungsi mirip dengan file .dll di Windows.\nWindows: Menggunakan .dll yang disimpan di C:\\Windows\\System32 atau di direktori aplikasi. FreeBSD/macOS: Sama seperti Linux, menggunakan /lib. /tmp Direktori ini digunakan untuk menyimpan file sementara. Biasanya, file di sini akan dihapus setelah sistem di-restart atau dalam waktu tertentu.\nWindows: Setara dengan C:\\Windows\\Temp, penjelasan lengkap bisa lihat disini. FreeBSD/macOS: Sama seperti Linux, menggunakan /tmp. /dev Berisi file device untuk perangkat keras yang terhubung ke sistem. Contoh:\n/dev/sda (representasi hard drive pertama) /dev/tty (terminal) Windows: Perangkat keras diakses melalui Device Manager. FreeBSD/macOS: Sama seperti Linux, menggunakan /dev. /mnt dan /media Direktori ini digunakan sebagai mount point untuk perangkat yang di-mount secara manual atau otomatis, seperti USB drive atau CD-ROM.\n/mnt: Biasanya digunakan untuk mounting manual. /media: Biasanya digunakan untuk mounting otomatis. Windows: Perangkat yang di-mount langsung terlihat sebagai drive letter (misalnya E:). FreeBSD/macOS: Menggunakan /mnt atau /Volumes (macOS). /opt Direktori ini digunakan untuk menginstal aplikasi pihak ketiga atau tambahan. Misalnya, jika Anda mengunduh aplikasi yang tidak dikelola oleh manajer paket sistem, Anda dapat menginstalnya di sini.\nWindows: Setara dengan C:\\Program Files. FreeBSD/macOS: Sama seperti Linux, menggunakan /opt. /proc Direktori virtual yang merepresentasikan informasi sistem dan proses yang sedang berjalan. Contoh file:\n/proc/cpuinfo (informasi tentang CPU) /proc/meminfo (informasi tentang penggunaan memori) Windows: Informasi sistem dapat diakses melalui Task Manager atau Registry. FreeBSD/macOS: Sama seperti Linux, menggunakan /proc. /sys Mirip dengan /proc, namun lebih berfokus pada perangkat keras dan perangkat yang dihubungkan ke kernel.\nWindows: Informasi perangkat keras diakses melalui Device Manager. FreeBSD/macOS: Sama seperti Linux, menggunakan /sys. /boot Berisi file yang diperlukan untuk booting sistem, seperti kernel Linux dan bootloader. Contoh file:\n/boot/vmlinuz (kernel Linux) /boot/grub (konfigurasi GRUB bootloader) Windows: File boot disimpan di partisi sistem, misalnya C:\\Boot. FreeBSD/macOS: Sama seperti Linux, menggunakan /boot. /swap Partisi atau file swap digunakan untuk memperluas kapasitas memori virtual. Ini tidak terlihat sebagai direktori tetapi merupakan bagian dari sistem file.\nWindows: Menggunakan file pagefile (pagefile.sys) sebagai swap. FreeBSD/macOS: Sama seperti Linux, menggunakan partisi atau file swap. Ketentuan Penggunaan Direktori di Linux Akses ke direktori tertentu membutuhkan hak superuser, misalnya /root, /etc, dan /boot. File konfigurasi utama harus disimpan di /etc. File sementara sebaiknya diletakkan di /tmp atau /var/tmp. File tambahan aplikasi pihak ketiga sebaiknya diletakkan di /opt atau /usr/local. Kesimpulan Memahami struktur direktori di Linux adalah langkah penting bagi siapa pun yang ingin belajar administrasi sistem atau sekadar memahami bagaimana sistem Linux bekerja. Dengan membandingkan Linux dengan Windows, FreeBSD, dan macOS, kita dapat melihat bahwa meskipun ada perbedaan, prinsip dasar yang diwarisi dari UNIX tetap menjadi fondasi kuat dari sistem operasi modern. ğŸš€ğŸš€ğŸš€\n","permalink":"https://catatandeveloper.id/memahami-directory-linux/","title":"Memahami Directory Linux"},{"content":" Linux adalah salah satu sistem operasi open-source yang paling populer di dunia. Berbeda dengan sistem operasi proprietari seperti Windows atau macOS, Linux memberikan kebebasan kepada pengguna untuk mengakses, memodifikasi, dan mendistribusikan ulang kode sumbernya. Hal ini menjadikan Linux pilihan utama bagi banyak pengembang, sistem administrator, dan pengguna biasa yang menghargai fleksibilitas serta kontrol penuh atas perangkat mereka.\nSejarah dan Penciptaan Linux Linux diciptakan oleh Linus Torvalds pada tahun 1991. Pada saat itu, Torvalds adalah seorang mahasiswa di Universitas Helsinki, Finlandia. Awalnya, ia mengembangkan kernel Linux sebagai proyek pribadi karena merasa tidak puas dengan keterbatasan sistem operasi Minix yang ia gunakan dalam perkuliahannya.\nPada 25 Agustus 1991, Torvalds mengumumkan proyeknya melalui sebuah posting di grup diskusi Usenet comp.os.minix, di mana ia menyatakan:\n\u0026ldquo;I\u0026rsquo;m doing a (free) operating system (just a hobby, won\u0026rsquo;t be big and professional like GNU) for 386(486) AT clones.\u0026rdquo;\nNamun, kernel Linux dengan cepat menarik perhatian banyak pengembang dari seluruh dunia yang kemudian berkontribusi untuk menyempurnakannya.\nProses Perkembangan Linux: Kernel Awal: Torvalds merilis kernel pertama (versi 0.01) pada September 1991, yang hanya dapat menjalankan perangkat keras berbasis arsitektur x86.\nOpen Source: Pada 1992, kernel Linux dirilis di bawah lisensi GNU General Public License (GPL), yang memungkinkan siapa saja untuk menggunakan, memodifikasi, dan mendistribusikan ulang kode sumbernya.\nKolaborasi Global: Dengan lisensi open-source, Linux mulai mendapatkan banyak kontributor dari komunitas global, sehingga pertumbuhannya menjadi sangat pesat.\nKemunculan Distro: Untuk membuat Linux lebih mudah digunakan, berbagai distribusi mulai dikembangkan dengan menggabungkan kernel Linux dan perangkat lunak tambahan.\nLinux: Kernel, Bukan Sistem Operasi Penting untuk dipahami bahwa Linux sebenarnya adalah kernel, yaitu inti dari sebuah sistem operasi yang mengelola perangkat keras dan sumber daya komputer. Kernel ini kemudian dipadukan dengan perangkat lunak lainnya untuk membentuk sistem operasi yang lengkap, yang dikenal sebagai distribusi Linux (distro Linux). Oleh karena itu, saat kita berbicara tentang \u0026ldquo;Linux\u0026rdquo;, kita sering merujuk pada distro-distro tersebut yang dirancang untuk berbagai kebutuhan.\nStruktur Linux Linux terdiri dari:\nKernel: Inti dari sistem operasi yang mengelola hardware dan sumber daya komputer.\nShell: Antarmuka pengguna untuk berinteraksi dengan kernel.\nFile System: Struktur direktori untuk menyimpan dan mengatur data.\nAplikasi: Berbagai perangkat lunak yang dapat dijalankan di atas sistem operasi.\nSejarah Distro Linux Sejak kernel Linux pertama kali dirilis, berbagai distribusi Linux mulai dikembangkan untuk memenuhi kebutuhan yang berbeda-beda.\nLihat Timeline Linux\n1993: Debian lahir sebagai salah satu distro komunitas tertua yang masih aktif hingga kini.\n1994: Red Hat Linux dirilis, yang kemudian menjadi dasar bagi Red Hat Enterprise Linux (RHEL) dan Fedora.\n2000: Knoppix memperkenalkan konsep live CD, memungkinkan pengguna menjalankan Linux tanpa instalasi.\n2004: Ubuntu dirilis dengan fokus pada kemudahan penggunaan, menjadikannya distro populer untuk pemula.\n2013: SteamOS, distro berbasis Debian, dirancang untuk gaming.\nSaat ini Terdapat ratusan distro Linux aktif, mulai dari yang umum digunakan hingga yang sangat spesifik untuk tugas tertentu.\nJenis-jenis Distro Linux Berdasarkan Kegunaan Distro Linux dirancang untuk berbagai kebutuhan spesifik. Berikut adalah kategori utama distro Linux berdasarkan kegunaannya:\nDistro untuk Pemula Dirancang untuk pengguna baru yang ingin beralih ke Linux dengan antarmuka yang ramah dan kemudahan penggunaan.\nContoh Distro: Ubuntu, Linux Mint, Zorin OS.\nDistro untuk Pengembangan Perangkat Lunak Distro ini menyediakan alat-alat yang mendukung pengembang untuk coding, testing, dan deployment.\nContoh Distro: Fedora, openSUSE, Manjaro.\nDistro untuk Server dan Jaringan Dirancang untuk keandalan dan stabilitas tinggi dalam menjalankan server dan infrastruktur jaringan.\nContoh Distro: Debian, CentOS, Red Hat Enterprise Linux (RHEL).\nDistro untuk Keamanan Siber Distro ini berisi alat khusus untuk pengujian penetrasi dan forensik digital.\nContoh Distro: Kali Linux, Parrot OS, BackBox.\nDistro untuk Kustomisasi Tinggi Cocok bagi pengguna mahir yang ingin membangun sistem operasi yang benar-benar sesuai dengan kebutuhan mereka.\nContoh Distro: Arch Linux, Gentoo, Slackware.\nDistro untuk Komputer Lama atau Ringan Dirancang untuk perangkat dengan spesifikasi rendah agar tetap dapat berjalan dengan baik.\nContoh Distro: Lubuntu, Xubuntu, Puppy Linux.\nDistro untuk Pendidikan Distro ini dirancang untuk mendukung pembelajaran di lingkungan pendidikan.\nContoh Distro: Edubuntu, UberStudent.\nPenggunaan Linux di Dunia Linux kini digunakan di berbagai sektor, dengan perkiraan 4% dari komputer desktop (sumber), tetapi mendominasi lebih dari 90% dari server dunia (sumber), termasuk server untuk situs web, email, dan database. Linux juga menguasai 73% dari perangkat mobile (berkat Android, yang berbasis kernel Linux)(sumber).\nIndustri yang Menggunakan Linux\nTeknologi Informasi dan Server: Mayoritas server internet menggunakan Linux karena stabilitas dan keamanannya.\nCloud Computing: Platform seperti AWS, Google Cloud, dan Microsoft Azure menggunakan Linux sebagai sistem operasi utama.\nIoT (Internet of Things): Linux digunakan dalam perangkat IoT seperti smart TV, router, dan perangkat rumah pintar.\nKeamanan Siber: Distribusi seperti Kali Linux digunakan untuk pengujian penetrasi dan forensik digital.\nPenerbangan dan Militer: Sistem kontrol pesawat, seperti yang digunakan dalam pembaruan F-22 Raptor oleh REDHAT, menggunakan Linux untuk meningkatkan efisiensi dan keamanan perangkat lunak.\nIndustri Film dan Animasi: Studio-studio besar seperti Pixar menggunakan Linux untuk rendering animasi dan efek visual.\nPendidikan: Banyak institusi pendidikan menggunakan Linux untuk mengajarkan dasar-dasar ilmu komputer.\nMengapa Memilih Linux? Ada banyak alasan mengapa Linux menjadi pilihan utama, di antaranya:\nGratis: Tidak perlu membayar lisensi.\nAman: Sistem yang lebih tahan terhadap malware.\nFleksibel: Dapat dikustomisasi sesuai kebutuhan.\nKomunitas: Dukungan komunitas yang luas dan aktif.\nKesimpulan Linux bukan hanya kernel; ia adalah ekosistem yang mendukung berbagai kebutuhan teknologi. Dengan banyaknya pilihan distro yang tersedia, setiap pengguna dapat menemukan yang paling sesuai dengan kebutuhan mereka. Bagi pemula, distro seperti Ubuntu atau Linux Mint adalah titik awal yang baik. Sedangkan bagi profesional, opsi seperti Fedora, Arch, atau Kali Linux menawarkan kemampuan yang lebih spesifik dan canggih.\nMulailah menjelajahi dunia Linux dan temukan bagaimana ia dapat memberikan solusi terbaik untuk kebutuhan teknologi Anda!ğŸš€ğŸš€ğŸš€\n","permalink":"https://catatandeveloper.id/pengenalan-linux-dan-jenis-distro/","title":"Pengenalan Linux Dan Jenis Distro Linux"},{"content":" User-Defined Data Type (UDT) adalah fitur yang sangat penting dalam bahasa pemrograman C++, yang memungkinkan pengembang untuk mendefinisikan tipe data mereka sendiri sesuai dengan kebutuhan. Dengan UDT, Anda dapat menyusun data yang kompleks dan merepresentasikan entitas dalam kode Anda.\nArtikel ini akan membahas konsep dasar UDT di C++, jenis-jenis UDT, dan contoh implementasinya.\n1. Apa itu User-Defined Data Type (UDT)? UDT adalah tipe data yang didefinisikan oleh pengguna untuk melengkapi atau memperluas tipe data bawaan (built-in) seperti int, float, dan char. Dengan UDT, Anda dapat membuat struktur data yang lebih kompleks, seperti objek, vektor, matriks, atau bahkan tipe data khusus untuk aplikasi tertentu.\nC++ menyediakan beberapa mekanisme untuk mendefinisikan UDT, seperti:\nStruct Class Enum Typedef dan Alias 2. Jenis-Jenis UDT di C++ Berikut adalah jenis-jenis UDT yang umum digunakan dalam C++:\nStruct (Struktur) struct adalah kumpulan variabel yang dikelompokkan bersama di bawah satu nama. Variabel-variabel ini dapat memiliki tipe data yang berbeda.\nContoh: #include \u0026lt;iostream\u0026gt; struct Point { int x; int y; }; int main() { Point p1 = {10, 20}; std::cout \u0026lt;\u0026lt; \u0026#34;Point: (\u0026#34; \u0026lt;\u0026lt; p1.x \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; p1.y \u0026lt;\u0026lt; \u0026#34;)\u0026#34; \u0026lt;\u0026lt; std::endl; return 0; }\nPadding di Struct Padding adalah proses di mana compiler menambahkan byte tambahan di antara anggota struct untuk memastikan bahwa setiap anggota disejajarkan dengan batas memori tertentu (alignment). Hal ini dilakukan untuk meningkatkan efisiensi akses memori pada platform tertentu.\nContoh Padding: #include \u0026lt;iostream\u0026gt; struct Example { char a; // 1 byte int b; // 4 bytes char c; // 1 byte }; int main() { // Output 12 std::cout \u0026lt;\u0026lt; \u0026#34;Size of struct Example: \u0026#34; \u0026lt;\u0026lt; sizeof(Example) \u0026lt;\u0026lt; \u0026#34; bytes\u0026#34; \u0026lt;\u0026lt; std::endl; return 0; }\nOutput ukuran struct Example lebih besar dari jumlah total ukuran anggotanya (1 + 4 + 1 = 6 bytes). Ini karena compiler menambahkan padding sesuai urutan pada deklasi yang setiap paddingnya hanya memiliki ukuran 4 bytes.\nCara Mengurangi Padding: Urutkan anggota struct dari yang terbesar ke yang terkecil.\nContoh Padding: #include \u0026lt;iostream\u0026gt; struct Example { int b; // 4 bytes char a; // 1 byte char c; // 1 byte }; int main() { // Output 8 std::cout \u0026lt;\u0026lt; \u0026#34;Size of struct Example: \u0026#34; \u0026lt;\u0026lt; sizeof(Example) \u0026lt;\u0026lt; \u0026#34; bytes\u0026#34; \u0026lt;\u0026lt; std::endl; return 0; } Dengan mengatur ulang urutan anggota, padding dapat diminimalkan, sehingga ukuran struct lebih efisien.\nClass (Kelas) class adalah bentuk lanjutan dari struct yang mendukung enkapsulasi, pewarisan, dan polimorfisme. Semua anggota class secara default bersifat private, sedangkan pada struct, default-nya adalah public.\nContoh: #include \u0026lt;iostream\u0026gt; class Rectangle { private: int length; int width; public: void setDimensions(int l, int w) { length = l; width = w; } int area() { return length * width; } }; int main() { Rectangle rect; rect.setDimensions(10, 5); std::cout \u0026lt;\u0026lt; \u0026#34;Area: \u0026#34; \u0026lt;\u0026lt; rect.area() \u0026lt;\u0026lt; std::endl; return 0; }\nEnum (Enumerasi) enum digunakan untuk mendefinisikan kumpulan nilai konstan yang dapat digunakan sebagai tipe data.\nContoh: #include \u0026lt;iostream\u0026gt; enum Color {RED, GREEN, BLUE}; int main() { Color favoriteColor = GREEN; if (favoriteColor == GREEN) { std::cout \u0026lt;\u0026lt; \u0026#34;Favorite color is Green!\u0026#34; \u0026lt;\u0026lt; std::endl; } return 0; }\nTypedef dan Alias typedef dan using digunakan untuk mendefinisikan alias bagi tipe data yang sudah ada.\nContoh: #include \u0026lt;iostream\u0026gt; typedef unsigned int uint; using uint_alias = unsigned int; int main() { uint x = 100; uint_alias y = 200; std::cout \u0026lt;\u0026lt; \u0026#34;x: \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34;, y: \u0026#34; \u0026lt;\u0026lt; y \u0026lt;\u0026lt; std::endl; return 0; }\nKesimpulan User-Defined Data Type (UDT) adalah alat yang kuat dalam C++ untuk membuat program yang lebih modular, fleksibel, dan dapat dipelihara. Dengan memahami berbagai jenis UDT seperti struct, class, enum, dan typedef, Anda dapat membuat solusi yang lebih efektif untuk berbagai masalah pemrograman. ğŸ‰ğŸ‰ğŸ‰\n","permalink":"https://catatandeveloper.id/user-defined-data-type-udt/","title":"User-Defined Data Type (UDT)"},{"content":" Dalam bahasa pemrograman C++, array dan string adalah dua tipe data penting yang sering digunakan untuk menyimpan dan memanipulasi data. Artikel ini akan membahas dasar-dasar array dan string serta cara penggunaannya dalam C++.\n1. Array Array adalah kumpulan elemen yang memiliki tipe data yang sama dan disimpan dalam memori secara berurutan. Array sering digunakan ketika kita ingin menyimpan beberapa nilai dengan tipe yang sama.\nDeklarasi dan Inisialisasi Array #include \u0026lt;iostream\u0026gt; int main() { // Deklarasi array tanpa inisialisasi int number[5]; // Deklarasi dan inisialisasi array int value[] = {10, 20, 30, 40, 50}; // Menampilkan elemen array for (int i = 0; i \u0026lt; 5; i++) { std::cout \u0026lt;\u0026lt; \u0026#34;Nilai ke-\u0026#34; \u0026lt;\u0026lt; i + 1 \u0026lt;\u0026lt; \u0026#34;: \u0026#34; \u0026lt;\u0026lt; value[i] \u0026lt;\u0026lt; std::endl; } return 0; } Fitur Penting Array Indeks Dimulai dari Nol: Indeks pertama array adalah 0, bukan 1. Ukuran Tetap: Setelah array dideklarasikan, ukurannya tidak dapat diubah. Multidimensional Array: C++ mendukung array multidimensi, seperti matriks. int matriks[2][3] = {{1, 2, 3}, {4, 5, 6}}; Keterbatasan Array Array bawaan C++ tidak memiliki metode bawaan seperti di beberapa bahasa lain (misalnya Python). Oleh karena itu, kita sering menggunakan STL (Standard Template Library) seperti std::vector untuk menangani array dinamis.\nString di C++ String adalah kumpulan karakter yang digunakan untuk merepresentasikan teks. Dalam C++, string dapat dideklarasikan menggunakan array karakter atau menggunakan kelas std::string dari pustaka standar.\nString sebagai Array Karakter #include \u0026lt;iostream\u0026gt; int main() { // Deklarasi string sebagai array karakter char name[] = \u0026#34;Halo\u0026#34;; // Menampilkan string std::cout \u0026lt;\u0026lt; \u0026#34;String: \u0026#34; \u0026lt;\u0026lt; name \u0026lt;\u0026lt; std::endl; return 0; } Keterbatasan String berbasis array karakter sulit untuk dimanipulasi karena kita harus mengatur panjang string secara manual.\nString Modern dengan std::string Kelas std::string lebih fleksibel dan menyediakan banyak metode untuk memanipulasi string.\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; int main() { // Deklarasi string std::string data = \u0026#34;Halo Dunia!\u0026#34;; // Operasi pada string cout \u0026lt;\u0026lt; \u0026#34;Panjang string: \u0026#34; \u0026lt;\u0026lt; dat5a.length() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;Karakter pertama: \u0026#34; \u0026lt;\u0026lt; salam[0] \u0026lt;\u0026lt; endl; // Menambahkan string data += \u0026#34; Selamat belajar C++!\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;String baru: \u0026#34; \u0026lt;\u0026lt; data \u0026lt;\u0026lt; endl; return 0; } Metode Penting pada std::string length(): Mengembalikan panjang string. substr(pos, len): Mengambil substring. find(substring): Mencari posisi substring. replace(pos, len, new_str): Mengganti bagian string. string teks = \u0026#34;Belajar C++\u0026#34;; std::cout \u0026lt;\u0026lt; teks.substr(8, 3) \u0026lt;\u0026lt; std::endl; // Output: C++ Menggunakan Pointer ke Karakter (char)* char* adalah cara tradisional untuk merepresentasikan string dalam C++. Ini merepresentasikan pointer ke array karakter yang diakhiri dengan karakter null (\\0). #include \u0026lt;iostream\u0026gt; int main() { // Deklarasi string sebagai char* char* msg = \u0026#34;Hello, World!\u0026#34;; // Menampilkan string std::cout \u0026lt;\u0026lt; \u0026#34;pesan: \u0026#34; \u0026lt;\u0026lt; msg \u0026lt;\u0026lt; std::endl; // Mengakses karakter individu std::cout \u0026lt;\u0026lt; \u0026#34;Karakter pertama: \u0026#34; \u0026lt;\u0026lt; msg[0] \u0026lt;\u0026lt; std::endl; return 0; }\nCatatan Penting: String yang dideklarasikan sebagai char* bersifat read-only jika diinisialisasi langsung dengan string literal.\nKesimpulan Array dan string adalah struktur data yang esensial dalam C++. Untuk penggunaan yang sederhana, array sudah cukup, tetapi untuk manipulasi teks yang kompleks, std::string adalah pilihan terbaik. char* dapat digunakan untuk kompatibilitas dengan C atau jika ingin kontrol lebih pada manipulasi data tingkat rendah. Memahami cara kerja keduanya akan membantu Anda menulis program C++ yang lebih efisien dan terorganisir.\nSemoga artikel ini membantu Anda memahami konsep array dan string di C++. Selamat belajar! ğŸ‰ğŸ‰ğŸ‰\n","permalink":"https://catatandeveloper.id/array-dan-string-c++/","title":"Array Dan String C++"},{"content":" Temporary file atau file sementara di Windows adalah file yang dibuat oleh sistem operasi, aplikasi, atau program tertentu untuk menyimpan data sementara selama operasi tertentu berlangsung. File ini biasanya digunakan untuk menyimpan informasi sementara yang hanya diperlukan dalam waktu singkat, misalnya selama pengeditan file, pengolahan data, atau instalasi software.\nFungsi Temporary File File sementara digunakan untuk menyimpan data sementara yang dibutuhkan oleh aplikasi selama proses berjalan, misalnya:\nAplikasi pengolah dokumen menyimpan versi sementara dokumen yang sedang dikerjakan untuk mencegah kehilangan data. Program instalasi menggunakan file sementara untuk menyimpan file yang sedang diekstrak atau disiapkan. Pemulihan data, Jika terjadi kegagalan aplikasi atau crash, temporary file dapat membantu memulihkan data yang belum disimpan. Peningkatan performa, Beberapa program menggunakan file sementara untuk menyimpan data cache yang sering diakses untuk meningkatkan performa. Lokasi Temporary File File sementara pada Windows biasanya disimpan di lokasi berikut:\nFolder khusus Windows %TEMP%: Merujuk ke folder temp untuk pengguna saat ini, misalnya: C:\\Users\\\u0026lt;NamaPengguna\u0026gt;\\AppData\\Local\\Temp C:\\Windows\\Temp: Folder temp untuk sistem secara umum. Lokasi aplikasi tertentu Beberapa aplikasi mungkin menyimpan file sementara di folder instalasi mereka atau di lokasi khusus lainnya. Dampak Negatif Jika Tidak Dikelola Memenuhi ruang penyimpanan secara bertahap. Mengurangi performa laptop atau komputer. Membuat sistem terasa lambat jika file terlalu banyak. Hapus File Temporary File temporary biasanya tidak lagi diperlukan setelah proses tertentu selesai. Berikut Langkah-langkah menghapusnya: Tekan Win + R, ketik %temp%, lalu tekan Enter. Pilih semua file (Ctrl + A), lalu hapus (Shift + Delete). Ulangi langkah dengan mengetik temp (tanpa tanda %) Pilih semua file (Ctrl + A), lalu hapus (Shift + Delete). Kosongkan Recycle Bin Recycle Bin menyimpan file yang dihapus hingga Anda mengosongkannya. Risiko dan Catatan Penting Tidak semua file sementara aman untuk dihapus: Beberapa file sementara mungkin masih digunakan oleh program yang sedang berjalan.\nPembersihan rutin dianjurkan: File sementara yang tidak dihapus bisa menghabiskan ruang penyimpanan dan memperlambat sistem.\nHati-hati saat menghapus manual: Pastikan untuk tidak menghapus file di luar direktori temp kecuali Anda yakin fungsinya.\n","permalink":"https://catatandeveloper.id/membersihkan-temporary-file-windows/","title":"Membersihkan Temporary File Windows"},{"content":" Blue Screen of Death (BSOD) adalah istilah umum untuk layar biru yang muncul ketika Windows mengalami kesalahan sistem kritis. BSOD menunjukkan bahwa sistem operasi tidak dapat melanjutkan operasi dengan aman karena adanya masalah yang serius, seperti kegagalan perangkat keras, konflik driver, atau bug perangkat lunak.\nCiri-Ciri Blue Screen Layar Biru: Muncul dengan teks putih atau kode kesalahan. Kode Kesalahan: Biasanya diikuti oleh pesan seperti \u0026#34;CRITICAL_PROCESS_DIED\u0026#34;, \u0026#34;IRQL_NOT_LESS_OR_EQUAL\u0026#34;, \u0026#34;SYSTEM_SERVICE_EXCEPTION\u0026#34; atau \u0026#34;PAGE_FAULT_IN_NONPAGED_AREA\u0026#34;.\nRestart Otomatis: Secara default, komputer biasanya akan restart otomatis setelah Bluescreen terjadi.\nCara Mencegah Bluesceen Blue Screen of Death (BSOD) biasanya terjadi karena masalah perangkat keras, driver, atau perangkat lunak. Berikut adalah beberapa cara untuk mencegahnya:\nPerbarui Sistem Operasi dan Driver\nUpdate Windows: Pastikan sistem operasi Anda selalu diperbarui dengan patch terbaru dari Microsoft. Perbarui driver perangkat keras: Gunakan driver terbaru untuk perangkat keras seperti kartu grafis, audio, atau chipset. Anda bisa mendapatkannya dari situs resmi produsen. Jaga Kesehatan Hardware\nPeriksa RAM dan Hard Disk: Tekan Win + R, ketik mdsched.exe, lalu tekan Enter. Cek suhu perangkat: Overheating dapat menyebabkan BSOD. Gunakan alat seperti HWMonitor atau Core Temp untuk memantau suhu CPU/GPU. Gunakan PSU yang memadai: Pastikan catu daya (PSU) mampu mendukung kebutuhan perangkat keras Anda. Lindungi Sistem dari Malware\nScan virus dan malware: Gunakan antivirus yang andal dan pastikan database virusnya selalu diperbarui. Hindari aplikasi berbahaya: Instal software hanya dari sumber tepercaya. Hindari Konflik Software\nPeriksa kompatibilitas aplikasi: Pastikan semua aplikasi yang diinstal kompatibel dengan sistem operasi Anda. Uninstall software bermasalah: Jika BSOD terjadi setelah menginstal aplikasi tertentu, coba hapus aplikasi tersebut. Kelola File Sistem\nSFC (System File Checker): Buka Command Prompt sebagai administrator. Ketik perintah sfc /scannow. DISM: Buka Command Prompt sebagai administrator. Ketik DISM /Online /Cleanup-Image /RestoreHealth Gunakan perintah untuk memperbaiki file sistem yang lebih dalam. Analisis Log BSOD\nJika bluescreen terjadi, catat kode error (misalnya, SYSTEM_SERVICE_EXCEPTION) dan gunakan alat seperti BlueScreenView untuk menganalisis penyebabnya. Pastikan perangkat keras seperti PSU, RAM, dan motherboard dalam kondisi baik. Gunakan perangkat keras dan software yang kompatibel dengan spesifikasi sistem Anda. Menerapkan langkah-langkah di atas secara konsisten dapat membantu mengurangi risiko bluescreen dan menjaga stabilitas serta performa komputer Anda.\n","permalink":"https://catatandeveloper.id/menjaga-komputer-laptop-dari-masalah-bluescreen/","title":"Menjaga Komputer/Laptop Dari Masalah Bluescreen"},{"content":" Modifier dan qualifier adalah konsep penting dalam bahasa pemrograman C++ yang membantu programmer mengontrol aksesibilitas, perilaku, dan karakteristik variabel, fungsi, dan kelas. Artikel ini akan membahas pengertian dan penggunaannya.\nModifier dalam C++ Modifier adalah kata kunci yang digunakan untuk memodifikasi properti dari sebuah variabel atau fungsi. Modifier ini memungkinkan Anda menentukan ukuran, jangkauan, atau perilaku suatu entitas.\nBerikut adalah beberapa modifier umum di C++:\n1. Signed dan Unsigned Modifier ini digunakan untuk menentukan apakah variabel dapat menyimpan nilai negatif atau hanya positif.\nContoh: unsigned int positiveNumber = 10; // Hanya untuk angka positif signed int anyNumber = -5; // Bisa untuk angka positif dan negatif 2. Short dan Long Modifier ini mengubah ukuran penyimpanan variabel, terutama pada tipe data integer.\nContoh: short int smallNumber = 100; // Biasanya 2 byte long int largeNumber = 10000; // Biasanya 4 atau 8 byte 3. Const Digunakan untuk mendeklarasikan variabel yang nilainya tidak dapat diubah setelah diinisialisasi.\nContoh: const int maxUsers = 100; // maxUsers = 200; // Error: Nilai tidak bisa diubah 4. Volatile Memberitahu compiler bahwa nilai variabel dapat berubah sewaktu-waktu di luar kontrol program (contoh: dalam aplikasi multithreading atau hardware).\nContoh: volatile int sensorValue; 5. Mutable Modifier ini digunakan dalam konteks kelas, memungkinkan anggota data untuk diubah meskipun objeknya bersifat const.\nContoh: class Example { mutable int counter; public: void increment() const { counter++; } }; Contoh lengkap: #include \u0026lt;iostream\u0026gt; class Example { private: mutable int counter1 = 0; int counter2 = 0 ; public: void Increment1() const { counter1++; } // error jika digunakan // void Increment2() const // { // counter2++; // } void Show() { std::cout\u0026lt;\u0026lt; \u0026#34;Increment 1 \u0026gt; \u0026#34; \u0026lt;\u0026lt; counter1\u0026lt;\u0026lt;std::endl; std::cout\u0026lt;\u0026lt; \u0026#34;Increment 2 \u0026gt; \u0026#34; \u0026lt;\u0026lt; counter2\u0026lt;\u0026lt;std::endl; } }; int main() { Example example; example.Increment1(); example.Show(); return 0; } Qualifier dalam C++ Qualifier adalah elemen yang memperketat atau memberikan batasan tambahan pada penggunaan variabel, pointer, atau fungsi.\n1. Const Qualifier Membuat variabel atau parameter tidak dapat dimodifikasi.\nContoh Const Value: const int value1 = 10, value2 = 20; const int* ptr = \u0026amp;value1; // *ptr = 30; // Error: Nilai yang ditunjuk tidak dapat diubah ptr = \u0026amp;value2; // Valid: Pointer dapat diarahkan ke lokasi lain Contoh Const Pointer: int value1 = 10, value2 = 20; int* const ptr = \u0026amp;value1; *ptr = 30; // Valid: Nilai yang ditunjuk dapat diubah // ptr = \u0026amp;value2; // Error: Pointer tidak dapat diarahkan ke lokasi lain Contoh Const Value dan Pointer: const int value1 = 10; const int* const ptr = \u0026amp;value1; // *ptr = 30; // Error: Nilai yang ditunjuk tidak dapat diubah // ptr = \u0026amp;value2; // Error: Pointer tidak dapat diarahkan ke lokasi lain Contoh parameter function: void printMessage(const std::string\u0026amp; message) { // message tidak dapat dimodifikasi std::cout \u0026lt;\u0026lt; message \u0026lt;\u0026lt; std::endl; } Contoh variable member function: #include \u0026lt;iostream\u0026gt; class Example { private: int counter = 0; public: void printMessage(const std::string\u0026amp; message) const { // kita tidak bisa melakukan perubahan variable member apapun disini // counter ++; // error std::cout \u0026lt;\u0026lt; message \u0026lt;\u0026lt; std::endl; } }; 2. Lvalue dan Rvalue Qualifier Qualifier ini digunakan untuk membatasi fungsi anggota hanya dapat dipanggil pada lvalue atau rvalue.\nContoh variable member function: #include \u0026lt;iostream\u0026gt; class Example { public: void show() \u0026amp; { std::cout \u0026lt;\u0026lt; \u0026#34;Lvalue\u0026#34;\u0026lt;\u0026lt;std::endl; } void show() \u0026amp;\u0026amp; { std::cout \u0026lt;\u0026lt; \u0026#34;Rvalue\u0026#34;\u0026lt;\u0026lt;std::endl; } }; int main() { Example e; e.show(); // Output: Lvalue Example().show(); // Output: Rvalue return 0; } 3. Override dan Final Qualifier yang digunakan pada metode virtual untuk memperjelas bahwa metode tersebut menggantikan metode dari kelas dasar atau tidak dapat di-override lagi.\nContoh: #include \u0026lt;iostream\u0026gt; class Base { public: virtual void display() const { std::cout \u0026lt;\u0026lt; \u0026#34;Base display\u0026#34; \u0026lt;\u0026lt; std::endl; } }; class Derived : public Base { public: void display() const override // Menggunakan override { std::cout \u0026lt;\u0026lt; \u0026#34;Derived display\u0026#34; \u0026lt;\u0026lt; std::endl; } }; class FinalDerived final : public Derived // Kelas ini tidak dapat diwarisi lagi { public: void display() const override // Menggunakan override { std::cout \u0026lt;\u0026lt; \u0026#34;FinalDerived display\u0026#34; \u0026lt;\u0026lt; std::endl; } }; // class AnotherDerived : public FinalDerived { // Error: FinalDerived tidak dapat diwarisi // }; int main() { Base* b = new Base(); Base* d = new Derived(); Base* f = new FinalDerived(); b-\u0026gt;display(); // Output: Base display d-\u0026gt;display(); // Output: Derived display f-\u0026gt;display(); // Output: FinalDerived display delete b; delete d; delete f; return 0; } Perbedaan Modifier dan Qualifier Modifier Qualifier Mengubah properti variabel Membatasi penggunaan entitas Contoh: short, long Contoh: const, override Fokus pada penyimpanan data Fokus pada aturan penggunaan data Kesimpulan Modifier dan qualifier adalah fitur penting yang membuat C++ fleksibel dan efisien. Dengan memahami penggunaannya, Anda dapat menulis kode yang lebih aman, terorganisasi, dan optimal.\n","permalink":"https://catatandeveloper.id/modifier-dan-qualifier-c++/","title":"Modifier Dan Qualifier C++"},{"content":" C++ adalah salah satu bahasa pemrograman yang memberikan fleksibilitas tinggi kepada pengembang, salah satunya melalui fitur pointer dan reference. Namun, konsep ini seringkali membingungkan pemula. Artikel ini akan menjelaskan secara rinci tentang pointer dan reference, serta kapan dan bagaimana menggunakannya.\nApa itu Pointer? Pointer(penunjuk) adalah variabel yang menyimpan alamat memori dari variabel lain. Pointer memungkinkan kita untuk mengakses dan memodifikasi nilai di memori secara langsung.\nDeklarasi Pointer: #include \u0026lt;iostream\u0026gt; int main() { int x = 10; int* ptr = \u0026amp;x; // Pointer ptr menyimpan alamat memori dari x std::cout \u0026lt;\u0026lt; *ptr; // Output: 10 } Penjelasan:\nint* ptr mendeklarasikan pointer ptr yang menunjuk ke tipe data int. \u0026amp;x mengambil alamat memori dari variabel x. Ilustrasi Memori: pada ilustrasi diatas bisa dilihat jika value dari variable ptr mengambil dari alamat memory di variable x, sehingga jika kita melakukan inisialisai dengan pointer( * ) maka value akan berubah menjadi alamat memory sesuai dengan contoh berikut:\n#include \u0026lt;iostream\u0026gt; int main() { int x = 10; int *ptr = \u0026amp;x; std::cout \u0026lt;\u0026lt; ptr; // Output: 0x100 } dan jika kita memberi pointer( * ) di variable ptr maka hasilnya adalah value x yaitu 10, hal ini sama saja dengan pointer( * ) digunakan untuk menunjuk ke alamat memory x dengan value 10.\njika kita melakukan perubahan terhadap ptr maka hasil x juga akan berubah, karena ptr mempunyai relasi memory yang sama dengan x.\n#include \u0026lt;iostream\u0026gt; int main() { int x = 10; int *ptr = \u0026amp;x; *ptr = 20; std::cout \u0026lt;\u0026lt; x; // Output: 20 } Multiple Pointer Multiple pointer digunakan untuk mengelola hierarki atau struktur data yang lebih kompleks, seperti array dua dimensi, daftar berantai (linked list), pohon biner, atau grafik. Pointer yang menunjuk ke pointer lain memungkinkan Anda mengelola hubungan antara data dengan lebih dinamis dan fleksibel.\n#include \u0026lt;iostream\u0026gt; int main() { int x = 10; int *ptr1 = \u0026amp;x; int **ptr2 = \u0026amp;ptr1; std::cout\u0026lt;\u0026lt; *(*ptr2) \u0026lt;\u0026lt; std::endl; // output 10 return 0; } Ilustrasi Memori: Apa Itu Reference? Reference adalah alias untuk variabel lain. Reference tidak menyimpan alamat memori seperti pointer, tetapi berfungsi sebagai nama kedua untuk variabel yang sama.\nDeklarasi Reference: #include \u0026lt;iostream\u0026gt; int main() { int x = 10; int\u0026amp; ref = x; // Reference ref adalah alias untuk y std::cout \u0026lt;\u0026lt; ref; // Output: 10 } Penjelasan:\nint\u0026amp; ref mendeklarasikan reference ref yang mengacu pada variabel x. Ilustrasi Memori: bisa dilihat bahwa varibale ref hanya menjadi alias dan tidak membuat memory baru.\nFunction reference dapat digunakan dalam fungsi untuk menghindari salinan data yang bisa membuat performa program lebih efisien.\n#include \u0026lt;iostream\u0026gt; void Increment(int\u0026amp; num) { num += 1; } int main() { int value = 5; Increment(value); std::cout \u0026lt;\u0026lt; value; // Output: 6 } Kesimpulan Pointer dan reference memiliki kelebihan masing-masing:\nGunakan pointer ketika Anda perlu bekerja dengan memori secara langsung atau mengelola alokasi memori dinamis. Gunakan reference untuk membuat kode lebih bersih dan menghindari salinan data yang tidak perlu. Dengan memahami kedua konsep ini, Anda dapat mengoptimalkan penggunaan memori dan meningkatkan efisiensi program Anda.\n","permalink":"https://catatandeveloper.id/pointer-dan-reference-c++/","title":"Pointer Dan Reference C++"},{"content":" Diskpart adalah utilitas baris perintah bawaan Windows yang digunakan untuk mengelola disk, partisi, dan volume. Alat ini lebih kuat dibandingkan Disk Management GUI karena memberikan akses langsung ke fungsi manajemen disk tingkat rendah.\nFungsi Diskpart Fungsi Deskripsi Membuat Partisi Membagi disk menjadi beberapa bagian (partisi). Menghapus Partisi Menghapus data dan struktur partisi dari disk. Memformat Disk/Partisi Mengatur file system seperti NTFS, FAT32, atau exFAT. Mengubah Atribut Disk Mengelola atribut, seperti menjadikan partisi aktif, mengatur read-only, atau atribut lainnya. Membersihkan Disk Menghapus seluruh data, termasuk partisi dan struktur disk (mengembalikan ke keadaan kosong). Mengkonversi Format Disk Mengubah format disk antara GPT (GUID Partition Table) dan MBR (Master Boot Record). Perintah Umum Diskpart Perintah Deskripsi list disk Menampilkan daftar semua disk yang terdeteksi di sistem. select disk [nomor_disk] Memilih disk yang akan dikelola (ganti [nomor_disk] dengan nomor disk yang diinginkan). list partition Memilih partisi yang akan dikelola (ganti [nomor_partisi] dengan nomor partisi). select partition [nomor_partisi] Mengelola atribut, seperti menjadikan partisi aktif, mengatur read-only, atau atribut lainnya. create partition primary size=[ukuran_MB] Membuat partisi baru dengan ukuran tertentu dalam megabyte. delete partition Menghapus partisi yang dipilih. format fs=[file_system] quick Memformat partisi dengan file system tertentu, seperti NTFS atau FAT32 (opsi quick untuk format cepat). assign letter=[huruf] Menetapkan huruf drive untuk partisi yang dipilih. active Menandai partisi yang dipilih sebagai aktif (digunakan untuk partisi boot). clean Menghapus seluruh partisi dan data pada disk yang dipilih, mengembalikannya ke keadaan kosong. convert mbr Mengonversi disk menjadi format MBR (Master Boot Record). convert gpt Mengonversi disk menjadi format GPT (GUID Partition Table). exit Keluar dari utilitas Diskpart. Cara Menggunakan Diskpart Membuka Diskpart Tekan Win + R, ketik diskpart, lalu tekan Enter. Perintah Umum Diskpart: ketik list disk, lalu tekan Enter. ketik select disk [nomor_disk], lalu tekan Enter. Contoh Penggunaan Diskpart. Misalnya, Anda ingin memformat flash drive: list disk select disk 1 clean create partition primary format fs=fat32 quick assign letter=F Flash drive Anda akan diformat dengan file system FAT32 dan diberi huruf F. Kesimpulan Secara keseluruhan, Diskpart adalah alat yang sangat berguna bagi administrator sistem atau pengguna yang membutuhkan kontrol lebih dalam pengelolaan disk dan partisi di Windows, namun harus digunakan dengan hati-hati untuk menghindari kesalahan yang dapat merusak data.\n","permalink":"https://catatandeveloper.id/penjelasan-diskpart-dan-cara-menggunakannya/","title":"Penjelasan Diskpart Dan Cara Menggunakannya"},{"content":" Regedit adalah singkatan dari Registry Editor, sebuah alat di Windows yang digunakan untuk melihat, mengedit, atau mengelola entri-entri dalam Windows Registry. Windows Registry adalah basis data hierarkis yang menyimpan pengaturan dan konfigurasi sistem operasi, perangkat keras, perangkat lunak, dan akun pengguna.\nFungsi Utama Regedit Melihat dan Mengedit Pengaturan Sistem: Digunakan untuk mengubah pengaturan sistem yang tidak tersedia melalui antarmuka grafis (GUI).\nMemecahkan Masalah Sistem: Berguna untuk troubleshooting masalah tertentu, seperti kesalahan aplikasi atau layanan yang tidak berjalan.\nMengelola Perangkat Lunak: Mengatur perilaku aplikasi tertentu dengan mengubah kunci registry yang terkait.\nMengontrol Hak Akses: Menyesuaikan izin akses registry untuk pengguna tertentu.\nMenghapus Sisa Aplikasi: Membersihkan entri registry yang tertinggal setelah uninstall program.\nCara Membuka Regedit Tekan Win + R, ketik regedit, lalu tekan Enter. Struktur Registry Windows Registry terdiri dari lima root utama, disebut juga Hive:\nHKEY_CLASSES_ROOT (HKCR): Menyimpan informasi tentang asosiasi file dan program. Contoh: Ekstensi .txt terhubung ke aplikasi Notepad.\nHKEY_CURRENT_USER (HKCU): Menyimpan pengaturan khusus untuk pengguna yang sedang login. Contoh: Preferensi tampilan desktop.\nHKEY_LOCAL_MACHINE (HKLM): Menyimpan pengaturan global untuk semua pengguna dan perangkat keras. Contoh: Konfigurasi driver atau layanan.\nHKEY_USERS (HKU): Berisi informasi untuk semua akun pengguna di komputer.\nHKEY_CURRENT_CONFIG (HKCC): Menyimpan informasi tentang konfigurasi perangkat keras yang sedang digunakan.\nContoh Penggunaan Regedit Mengubah Nama Pemilik Komputer: Navigasi ke: HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion Ubah nilai pada RegisteredOwner. Contoh penggunakan regedit juga dapat Menon-Aktikan Windows Update, sama seperti penjelasan sebelumnya pada postingan: https://catatandeveloper.id/cara-nonaktifkan-windows-update-otomatis\nTips Menggunakan Regedit Backup Registry Sebelum Mengedit: Sebelum melakukan perubahan, backup dengan cara: Klik kanan pada kunci registry yang ingin diubah. Pilih Export, lalu simpan file .reg. Hati-Hati Saat Mengedit: Kesalahan dalam mengubah registry dapat menyebabkan masalah serius pada sistem, seperti crash atau aplikasi tidak berfungsi.\nGunakan Fitur Search: Tekan Ctrl + F untuk mencari entri registry tertentu. Jangan Menghapus Tanpa Tahu Dampaknya: Jika tidak yakin, lebih baik mencari informasi atau meminta bantuan profesional.\nKesimpulan: Regedit adalah alat yang sangat kuat tetapi berisiko jika tidak digunakan dengan hati-hati. Ini dirancang untuk pengguna tingkat lanjut, administrator, atau teknisi IT yang memahami dampak perubahan pada Windows Registry. Dengan penggunaan yang benar, Regedit dapat memecahkan banyak masalah sistem, meningkatkan performa, atau memberikan kontrol lebih besar atas sistem operasi.\n","permalink":"https://catatandeveloper.id/penjelasan-regedit-dan-cara-menggunakannya/","title":"Penjelasan Regedit dan Cara Menggunakannya"},{"content":" Function atau fungsi dalam C++ adalah blok kode yang dirancang untuk melakukan tugas tertentu. Fungsi digunakan untuk mengorganisasi program menjadi bagian-bagian yang lebih kecil dan lebih mudah dikelola. Dengan memanfaatkan fungsi, kamu dapat menghindari pengulangan kode, meningkatkan keterbacaan, dan mempermudah debugging.\nStruktur Dasar Fungsi dalam C++ Setiap fungsi dalam C++ memiliki struktur dasar seperti berikut:\n\u0026lt;tipe_data_pengembalian\u0026gt; nama_fungsi(\u0026lt;parameter\u0026gt;) { // Blok kode return nilai; } \u0026lt;tipe_data_pengembalian\u0026gt;: Menentukan jenis data yang dikembalikan oleh fungsi (contoh: int, float, void, dll.). nama_fungsi: Nama yang unik untuk mengidentifikasi fungsi. \u0026lt; parameter \u0026gt;: Daftar variabel yang diterima oleh fungsi, dipisahkan dengan koma. return nilai;: Digunakan untuk mengembalikan hasil ke pemanggil fungsi (opsional untuk fungsi void). Contoh Fungsi Sederhana Berikut contoh fungsi untuk menjumlahkan dua bilangan:\n#include \u0026lt;iostream\u0026gt; // Deklarasi fungsi int Add(int a, int b) { return a + b; } int main() { int x = 5, y = 10; int result = Add(x, y); std::cout \u0026lt;\u0026lt; \u0026#34;Hasil penjumlahan: \u0026#34; \u0026lt;\u0026lt; result \u0026lt;\u0026lt; std::endl; return 0; } Jenis-Jenis Fungsi dalam C++ 1. Fungsi Void Fungsi yang tidak mengembalikan nilai apapun:\nvoid Show() { std::cout \u0026lt;\u0026lt; \u0026#34;Halo, Dunia!\u0026#34; \u0026lt;\u0026lt; std::endl; } 2. Fungsi Rekursif Fungsi yang memanggil dirinya sendiri:\nint Faktorial(int n) { if (n \u0026lt;= 1) return 1; return n * Faktorial(n - 1); } 3. Fungsi Overloading Fungsi dengan nama yang sama tetapi parameter berbeda:\nint Add(int a, int b) { return a + b; } double Add(double a, double b) { return a + b; } 4. Fungsi Lambda Fungsi anonim yang digunakan untuk operasi sederhana:\n[ capture_list ] ( parameter_list ) -\u0026gt; return_type { // body }; Penjelasan setiap bagian:\ncapture_list: Menentukan variabel dari lingkup sekitar yang dapat diakses dalam lambda. parameter_list: Daftar parameter (mirip dengan fungsi biasa). return_type: (Opsional) Jenis data yang dikembalikan oleh lambda. Jika diabaikan, akan ditentukan secara otomatis. Contoh: int x = 10, y = 20; auto add = [x, y]() { return x + y; }; std::cout \u0026lt;\u0026lt; \u0026#34;Jumlah: \u0026#34; \u0026lt;\u0026lt; add() \u0026lt;\u0026lt; std::endl; Lambda sendiri diperkenalkan pertama kali di C++11 dan telah mengalami peningkatan di versi-versi berikutnya.\nCapture List pada Lambda capture_list menentukan bagaimana variabel dari lingkup luar dapat diakses di dalam lambda. Ada beberapa cara menangkap variabel:\n[ ]: Tidak menangkap variabel apa pun. [=]: Menangkap semua variabel di lingkup luar dengan nilai. [\u0026amp;]: Menangkap semua variabel di lingkup luar dengan referensi. [variable]: Menangkap variabel tertentu dengan nilai. [\u0026amp;variable]: Menangkap variabel tertentu dengan referensi. Contoh: int a = 5, b = 10; // Menangkap dengan nilai auto lambda1 = [=]() { return a + b; // a dan b hanya dapat dibaca }; // Menangkap dengan referensi auto lambda2 = [\u0026amp;]() { a += 10; // a dapat diubah return a + b; }; std::cout \u0026lt;\u0026lt; \u0026#34;Lambda1: \u0026#34; \u0026lt;\u0026lt; lambda1() \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;Lambda2: \u0026#34; \u0026lt;\u0026lt; lambda2() \u0026lt;\u0026lt; std::endl; Kesimpulan Fungsi adalah salah satu konsep dasar dalam pemrograman C++ yang sangat penting untuk dipahami. Dengan memahami fungsi, kamu dapat membuat program yang lebih terstruktur, efisien, dan mudah di-maintain. Jangan ragu untuk bereksperimen dengan berbagai jenis fungsi untuk menyelesaikan berbagai masalah pemrograman!ğŸ‰ğŸ‰ğŸ‰\n","permalink":"https://catatandeveloper.id/function-c++/","title":"Function C++"},{"content":" Perulangan (looping) adalah salah satu konsep penting dalam pemrograman, termasuk di C++. Dengan menggunakan perulangan, kita dapat menjalankan suatu blok kode secara berulang hingga kondisi tertentu terpenuhi. Artikel ini akan membahas berbagai jenis perulangan di C++, beserta contohnya.\nPerulangan for Perulangan for digunakan ketika jumlah iterasi sudah diketahui sebelumnya. Struktur dasarnya adalah:\nfor (inisialisasi; kondisi; perubahan) { // blok kode yang akan dijalankan } Contoh: Menampilkan angka 1 hingga 5.: #include \u0026lt;iostream\u0026gt; int main() { for (int i = 1; i \u0026lt;= 5; i++) { std::cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } return 0; } Output: 1 2 3 4 5 Perulangan while Perulangan while digunakan ketika kita ingin mengevaluasi kondisi terlebih dahulu sebelum menjalankan blok kode. Struktur dasarnya adalah:\nwhile (kondisi) { // blok kode yang akan dijalankan } Contoh: Menampilkan angka 1 hingga 5.: #include \u0026lt;iostream\u0026gt; int main() { int i = 1; while (i \u0026lt;= 5) { std::cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34; \u0026#34;; i++; } return 0; } Output: 1 2 3 4 5 Perulangan do-while Perulangan do-while menjamin bahwa blok kode dijalankan setidaknya sekali sebelum mengevaluasi kondisi. Struktur dasarnya adalah:\ndo { // blok kode yang akan dijalankan } while (kondisi); Contoh: Menampilkan angka 1 hingga 5.: #include \u0026lt;iostream\u0026gt; int main() { int i = 1; do { std::cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34; \u0026#34;; i++; } while (i \u0026lt;= 5); return 0; } Output: 1 2 3 4 5 Perulangan Bersarang (Nested Loop) Perulangan dapat bersarang di dalam perulangan lainnya untuk menyelesaikan masalah yang lebih kompleks.\n#include \u0026lt;iostream\u0026gt; int main() { for (int i = 1; i \u0026lt;= 3; i++) { for (int j = 1; j \u0026lt;= 3; j++) { std::cout \u0026lt;\u0026lt; i * j \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } std::cout \u0026lt;\u0026lt; std::endl; } return 0; } Output: 1 2 3 2 4 6 3 6 9 Kata Kunci dalam Perulangan break Digunakan untuk keluar dari perulangan sebelum waktunya.\n#include \u0026lt;iostream\u0026gt; int main() { for (int i = 1; i \u0026lt;= 10; i++) { if (i == 5) { break; } std::cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } return 0; } Output: 1 2 3 4 continue Digunakan untuk melompati iterasi saat ini dan melanjutkan ke iterasi berikutnya.\n#include \u0026lt;iostream\u0026gt; int main() { for (int i = 1; i \u0026lt;= 5; i++) { if (i == 3) { continue; } std::cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } return 0; } Output: 1 2 4 5 Perulangan tak hingga Kamu bisa membuat perulangan berjalan terus menerus secara tak hingga, ini biasanya digunakan di sistem yang membutuhkan running program terus menerus seperti embedded, komunikasi dan lain sebagainya.\nMenggunakan while #include \u0026lt;iostream\u0026gt; int main() { while (true) { // blok kode untuk setiap elemen } return 0; } Menggunakan for #include \u0026lt;iostream\u0026gt; int main() { for (;;) { // blok kode untuk setiap elemen } return 0; } menggunakan for secara estetika lebih baik jika kamu benar-benar menginginkan program berjalan terus menerus, hal ini dikarenakan memberikan kesan tidak ambigu jika di bandingkan dengan while(true);, karena true bersifat logika yang bisa saja menjadi false, meskipun didalam for tak hingga bisa di break, tetapi memahami hal seperti ini membuat kode kamu lebih baik secara penulisan.\nRange-based for loop Dalam C++, for(:) adalah sintaks untuk range-based for loop, yang digunakan untuk mengiterasi elemen dalam koleksi seperti array, std::vector, atau objek yang mendukung iterasi. Loop ini lebih sederhana dan sering digunakan ketika kita hanya perlu mengakses elemen tanpa memanipulasi indeks.\n#include \u0026lt;iostream\u0026gt; int main() { for (auto elemen : collections) { // blok kode untuk setiap elemen } } auto: Secara otomatis mendeteksi tipe data elemen dalam koleksi. elemen: Merujuk ke setiap item dalam koleksi. koleksi: Array, std::vector, atau struktur data lain yang mendukung iterasi. Contoh array: #include \u0026lt;iostream\u0026gt; int main() { int numbers[] = {1, 2, 3, 4, 5}; for (auto number : numbers) { std::cout \u0026lt;\u0026lt; number \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } return 0; } Output: 1 2 3 4 5 Contoh vector: #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; int main() { std::vector\u0026lt;int\u0026gt; numbers = {10, 20, 30, 40, 50}; for (auto number : numbers) { std::cout \u0026lt;\u0026lt; number \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } return 0; } Output: 10 20 30 40 50 Memodifikasi data Jika kamu ingin memodifikasi elemen dalam koleksi, gunakan referensi (\u0026amp;):\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; int main() { std::vector\u0026lt;int\u0026gt; numbers = {10, 20, 30}; for (auto\u0026amp; elemen : numbers) { elemen *= 2; // Menggandakan nilai setiap elemen } for (auto elemen : numbers) { std::cout \u0026lt;\u0026lt; elemen \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } return 0; } Output: 20 40 60 Kesimpulan Memahami dan menguasai perulangan dalam C++ sangat penting untuk menyelesaikan berbagai masalah pemrograman. Dengan memanfaatkan jenis-jenis perulangan seperti for, while, do-while, serta kata kunci break dan continue, Kamu dapat membuat program yang lebih efisien dan fleksibel. ğŸ‰ğŸ‰ğŸ‰\n","permalink":"https://catatandeveloper.id/perulangan-c++/","title":"Perulangan C++"},{"content":" Kondisi (condition) adalah salah satu konsep fundamental dalam pemrograman, termasuk di C++. Kondisi memungkinkan program untuk membuat keputusan berdasarkan nilai tertentu. Dengan kondisi, kita dapat mengarahkan alur eksekusi program sesuai dengan kebutuhan.\nStruktur Dasar Kondisi di C++ Struktur dasar untuk menggunakan kondisi dalam C++ adalah dengan pernyataan if, else if, dan else. Berikut adalah contoh sederhana:\n#include \u0026lt;iostream\u0026gt; int main() { int value; std::cout \u0026lt;\u0026lt; \u0026#34;Masukkan nilai: \u0026#34;; std::cin \u0026gt;\u0026gt; value; if (value \u0026gt;= 90) { std::cout \u0026lt;\u0026lt; \u0026#34;Anda mendapatkan nilai A\\n\u0026#34;; } else if (value \u0026gt;= 80) { std::cout \u0026lt;\u0026lt; \u0026#34;Anda mendapatkan nilai B\\n\u0026#34;; } else if (value \u0026gt;= 70) { std::cout \u0026lt;\u0026lt; \u0026#34;Anda mendapatkan nilai C\\n\u0026#34;; } else { std::cout \u0026lt;\u0026lt; \u0026#34;Anda perlu belajar lebih giat\\n\u0026#34;; } return 0; } Operator Logika Sesuai yang kita pelajari di materi operator, pernyataan kondisi sering kali melibatkan operator logika:\n#include \u0026lt;iostream\u0026gt; int main() { int old; std::cout \u0026lt;\u0026lt; \u0026#34;Masukkan umur Anda: \u0026#34;; std::cin \u0026gt;\u0026gt; old; if (old \u0026gt;= 18 \u0026amp;\u0026amp; old \u0026lt;= 60) { std::cout \u0026lt;\u0026lt; \u0026#34;Anda termasuk usia produktif.\\n\u0026#34;; } else { std::cout \u0026lt;\u0026lt; \u0026#34;Anda tidak termasuk usia produktif.\\n\u0026#34;; } return 0; } Pernyataan Ternary Selain if, C++ menyediakan operator ternary untuk kondisi sederhana. Sintaksnya adalah:\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;string.h\u0026gt; int main() { int number; std::cout \u0026lt;\u0026lt; \u0026#34;Masukkan sebuah angka: \u0026#34;; std::cin \u0026gt;\u0026gt; number; std::string result = (number % 2 == 0 ? \u0026#34;Angka genap\u0026#34; : \u0026#34;Angka ganjil\u0026#34;); std::cout \u0026lt;\u0026lt; result \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; return 0; } Switch Case Untuk kondisi yang melibatkan banyak kemungkinan nilai diskrit, kita dapat menggunakan switch. #include \u0026lt;iostream\u0026gt; int main() { int days; std::cout \u0026lt;\u0026lt; \u0026#34;Masukkan nomor hari (1-7): \u0026#34;; std::cin \u0026gt;\u0026gt; days; switch (days) { case 1: std::cout \u0026lt;\u0026lt; \u0026#34;Hari Minggu\\n\u0026#34;; break; case 2: std::cout \u0026lt;\u0026lt; \u0026#34;Hari Senin\\n\u0026#34;; break; case 3: std::cout \u0026lt;\u0026lt; \u0026#34;Hari Selasa\\n\u0026#34;; break; case 4: std::cout \u0026lt;\u0026lt; \u0026#34;Hari Rabu\\n\u0026#34;; break; case 5: std::cout \u0026lt;\u0026lt; \u0026#34;Hari Kamis\\n\u0026#34;; break; case 6: std::cout \u0026lt;\u0026lt; \u0026#34;Hari Jumat\\n\u0026#34;; break; case 7: std::cout \u0026lt;\u0026lt; \u0026#34;Hari Sabtu\\n\u0026#34;; break; default: std::cout \u0026lt;\u0026lt; \u0026#34;Nomor hari tidak valid\\n\u0026#34;; } return 0; }\nTips dan Best Practice Gunakan Blok \u0026ldquo;else if\u0026rdquo; dengan Bijak: Jangan membuat terlalu banyak cabang, karena bisa membuat kode sulit dibaca. Pertimbangkan menggunakan switch jika nilai kondisinya diskrit.\nSelalu Tambahkan Blok \u0026ldquo;else\u0026rdquo;: Meskipun opsional, menambahkan blok else dapat menangani kasus tak terduga.\nGunakan Operator Ternary untuk Sederhana: Hanya gunakan operator ternary untuk kondisi sederhana, agar kode tetap mudah dipahami.\nGunakan Kurung Kurawal untuk Keamanan: Walaupun tidak wajib, selalu gunakan kurung kurawal {} untuk setiap cabang kondisi untuk menghindari bug.\nKesimpulan Pemahaman tentang kondisi sangat penting untuk membuat program yang interaktif dan dinamis. Dengan menggunakan if, else if, else, operator ternary, dan switch, Kamu dapat membuat program yang lebih fleksibel dan responsif terhadap masukan pengguna. ğŸ‰ğŸ‰ğŸ‰\n","permalink":"https://catatandeveloper.id/kondisi-c++/","title":"Kondisi C++"},{"content":" DxDiag adalah singkatan dari DirectX Diagnostic Tool, sebuah alat bawaan Windows yang digunakan untuk mendiagnosis dan memecahkan masalah yang berkaitan dengan DirectX. DirectX adalah kumpulan antarmuka pemrograman aplikasi (API) yang dikembangkan oleh Microsoft, yang berfungsi untuk mengelola tugas-tugas multimedia seperti grafis game dan pemutaran video.\nFungsi DxDiag Informasi Sistem. DxDiag memberikan rincian tentang spesifikasi sistem Anda, termasuk: - Versi sistem operasi. - Prosesor (CPU). - Memori (RAM). - Informasi komputer (nama dan model).\nDiagnosa Masalah Hardware dan Software. Alat ini membantu mendeteksi masalah yang terkait dengan: Kartu grafis. Driver perangkat keras (seperti driver grafis dan suara). Kompatibilitas DirectX.\nInformasi tentang Kartu Grafis (Display). DxDiag menampilkan detail tentang kartu grafis Anda, seperti: Nama kartu grafis. Driver yang digunakan. Memori yang tersedia. Dukungan fitur grafis seperti Direct3D dan DirectDraw.\nInformasi Audio. Menyediakan informasi tentang perangkat audio, termasuk: Nama perangkat audio. Driver yang digunakan. Masalah kompatibilitas.\nLog dan File Diagnosa. DxDiag dapat menghasilkan file laporan dalam format teks (dxdiag.txt) yang dapat digunakan oleh teknisi atau pengembang untuk menganalisis masalah lebih lanjut.\nCara Menggunakan DxDiag Buka DxDiag Tekan Win + R, ketik dxdiag, lalu tekan Enter. 2.Navigasi dalam DxDiag. Anda akan melihat beberapa tab seperti: System: Menampilkan informasi sistem umum. Display: Detail kartu grafis. Sound: Informasi perangkat suara. Input: Informasi perangkat input seperti keyboard dan mouse. Simpan Laporan Klik tombol Save All Information untuk menyimpan laporan dalam format teks. Kesimpulan tentang DxDiag: DxDiag (DirectX Diagnostic Tool) adalah alat bawaan Windows yang digunakan untuk mendiagnosis dan menyelesaikan masalah terkait DirectX, perangkat keras grafis, dan audio. Alat ini memberikan informasi sistem, kartu grafis, perangkat suara, dan perangkat input. DxDiag berguna untuk memeriksa kompatibilitas perangkat keras, mengidentifikasi masalah driver, dan menghasilkan laporan diagnostik yang dapat membantu teknisi atau pengembang dalam memecahkan masalah komputer.\n","permalink":"https://catatandeveloper.id/penjelasan-dxdiag-dan-cara-menggunakannya/","title":"Penjelasan DxDiag Dan Cara Menggunakannya"},{"content":" Operator adalah simbol atau karakter khusus yang digunakan dalam pemrograman untuk melakukan operasi tertentu. Dalam bahasa C++, operator digunakan untuk memanipulasi data dan variabel. Artikel ini akan membahas berbagai jenis operator dalam C++ beserta contohnya.\nJenis-jenis Operator di C++ Operator Aritmatika Operator ini digunakan untuk melakukan operasi matematika seperti penjumlahan, pengurangan, perkalian, pembagian, dan modulus.\nOperator Deskripsi Contoh + Penjumlahan a + b - Pengurangan a - b * Perkalian a * b / Pembagian a / b % Modulus a % b Contoh Code: int a = 10, b = 3; std::cout \u0026lt;\u0026lt; \u0026#34;Penjumlahan: \u0026#34; \u0026lt;\u0026lt; a + b \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;Modulus: \u0026#34; \u0026lt;\u0026lt; a % b \u0026lt;\u0026lt; std::endl; Operator Relasional Operator ini digunakan untuk membandingkan dua nilai.\nOperator Deskripsi Contoh == Sama dengan a == b != Tidak sama dengan a != b \u003e Lebih dari a \u003e b \u003c Kurang dari a \u003c b \u003e= Lebih dari atau Sama a \u003e= b \u003c= Kurang dari atau sama a \u003c= b Contoh Code: int a = 5, b = 8; if (a \u0026lt; b) { std::cout \u0026lt;\u0026lt; \u0026#34;a lebih kecil dari b\u0026#34; \u0026lt;\u0026lt; std::endl; } Operator Logika Operator ini digunakan untuk operasi logika pada ekspresi boolean.\nOperator Deskripsi Contoh \u0026\u0026 AND (dan) a \u0026\u0026 b ! NOT (tidak) a ! b | OR (atau) a | b Contoh Code: bool a = true, b = false; if (a \u0026amp;\u0026amp; !b) { std::cout \u0026lt;\u0026lt; \u0026#34;Kondisi benar\u0026#34; \u0026lt;\u0026lt; std::endl; } Operator Assignment Operator ini digunakan untuk menetapkan nilai ke variabel.\nOperator Deskripsi Contoh = Assignment a = b += Tambah dan assign a += b -= Kurang dan assign a -= b *= Kali dan assign a *= b /= Bagi dan assign a /= b %= Modulus dan assign a %= b Contoh Code: int a = 5; a += 3; // a sekarang bernilai 8 Operator Bitwise Operator ini digunakan untuk operasi bit pada data.\nOperator Deskripsi Contoh \u0026 AND bitwise a = b | OR bitwise a | b ^ XOR bitwise a ^ b ~ NOT bitwise a ~ b \u003c\u003c Shift kiri a \u003c\u003c b \u003e\u003e Shift kanan a \u003e\u003e b Contoh Code: int a = 5; // 0101 dalam biner int b = 3; // 0011 dalam biner std::cout \u0026lt;\u0026lt; \u0026#34;Hasil AND: \u0026#34; \u0026lt;\u0026lt; (a \u0026amp; b) \u0026lt;\u0026lt; std::endl; Kesimpulan Operator dalam C++ adalah elemen penting untuk menulis kode yang efektif dan efisien. Dengan memahami dan menggunakan operator dengan tepat, kamu dapat meningkatkan kemampuan pemrograman kamu dan membuat program yang lebih kuat dan fleksibel. Mulailah berlatih menggunakan berbagai operator ini untuk memahami fungsinya secara mendalam!\n","permalink":"https://catatandeveloper.id/operator-c++/","title":"Operator C++"},{"content":" Windows Update otomatis di Windows 10 adalah fitur bawaan yang dirancang untuk memastikan sistem operasi selalu diperbarui dengan patch keamanan terbaru, pembaruan perangkat lunak, dan perbaikan bug. Dengan fitur ini, Windows secara otomatis mengunduh dan menginstal pembaruan tanpa memerlukan intervensi pengguna.\nKeuntungan Windows Update Otomatis:\nKeamanan Terjaga: Patch keamanan diterapkan segera setelah dirilis, melindungi sistem dari ancaman terbaru Performa Optimal: Pembaruan sering kali mencakup peningkatan kinerja dan perbaikan bug. Kompatibilitas Perangkat: Pembaruan driver membantu memastikan perangkat keras bekerja dengan baik. Kekurangan Windows Update Otomatis:\nGangguan Aktivitas: Kadang-kadang pembaruan dilakukan di waktu yang kurang nyaman. Masalah Kompatibilitas: Beberapa pembaruan bisa menyebabkan masalah dengan aplikasi tertentu atau perangkat keras. Penggunaan Data: Pembaruan besar dapat menghabiskan kuota data internet, terutama pada koneksi metered. Mengapa Ada Fitur Ini di Windows 10?\nMicrosoft mengaktifkan pembaruan otomatis untuk memastikan semua perangkat mendapatkan perlindungan terbaru secara konsisten. Ini juga membantu perusahaan mengurangi fragmentasi versi sistem operasi yang berbeda-beda di antara pengguna.\nNamun, meskipun fitur ini bermanfaat, beberapa pengguna memilih untuk menonaktifkannya karena alasan seperti kontrol lebih besar atas pembaruan, menghindari gangguan, atau menghemat kuota data.\nBerikut adalah cara untuk menonaktifkan pembaruan otomatis di Windows. Pastikan Anda memahami bahwa menonaktifkan pembaruan dapat membuat komputer lebih rentan terhadap ancaman keamanan. Berikut langkah-langkah lengkap untuk menonaktifkan pembaruan otomatis di Windows 10:\n1. Melalui Services (Menonaktifkan Layanan Windows Update)\nBuka Services Tekan Win + R, ketik services.msc, lalu tekan Enter. Cari Windows Update: Dalam daftar layanan, cari Windows Update. Klik kanan pada Windows Update, pilih Properties. Pada bagian Startup type, ubah menjadi Disabled. Klik Stop jika layanan sedang berjalan. Klik OK untuk menyimpan pengaturan. 2. Melalui Group Policy Editor (Hanya untuk Windows 10 Pro, Enterprise, atau Education)\nBuka Group Policy Editor: Tekan Win + R, ketik gpedit.msc, lalu tekan Enter. Navigasi ke Konfigurasi Windows Update: Masuk ke: Computer Configuration \u0026gt; Administrative Templates \u0026gt; Windows Components \u0026gt; Windows Update. Atur Automatic Updates: Klik dua kali Configure Automatic Updates. Pilih Disabled, lalu klik OK. 3. Melalui Registry Editor (Hati-hati dalam menggunakan metode ini)\nBuka Registry Editor: Tekan Win + R, ketik regedit, lalu tekan Enter. Navigasi ke Lokasi: HKEY_LOCAL_MACHINE\\SOFTWARE\\Policies\\Microsoft\\Windows\\WindowsUpdate\\AU. Buat Nilai Baru: Jika folder WindowsUpdate atau AU tidak ada, buat folder tersebut. Buat DWORD baru bernama NoAutoUpdate. Setel nilainya menjadi 1. Restart Komputer: Setelah selesai, restart komputer agar perubahan berlaku. Peringatan: Menonaktifkan Windows Update otomatis di Windows 10 dapat dilakukan melalui beberapa metode seperti Services, Group Policy Editor, atau Registry Editor. Metode ini memberikan kontrol lebih besar kepada pengguna atas kapan dan bagaimana pembaruan diinstal, sehingga dapat menghindari gangguan aktivitas atau penggunaan data yang tidak diinginkan.\nNamun, langkah ini juga memiliki risiko, terutama terhadap keamanan sistem, karena Anda mungkin melewatkan pembaruan penting seperti patch keamanan. Sebaiknya, jika memutuskan untuk menonaktifkan pembaruan otomatis, lakukan pembaruan manual secara berkala untuk menjaga sistem tetap aman dan stabil.\n","permalink":"https://catatandeveloper.id/cara-nonaktifkan-windows-update-otomatis/","title":"Cara Non-Aktifkan Windows Update Otomatis"},{"content":" Rufus adalah aplikasi perangkat lunak gratis yang digunakan untuk membuat USB bootable atau perangkat penyimpanan eksternal yang dapat digunakan untuk menginstal sistem operasi (seperti Windows atau Linux) atau menjalankan aplikasi tertentu langsung dari USB. Aplikasi ini sangat populer di kalangan pengguna komputer karena kemudahan dan kecepatannya dalam membuat media bootable.\nBerikut adalah penjelasan fitur-fitur utama dari Rufus:\nMembuat USB Bootable: Rufus memungkinkan pengguna untuk membuat USB yang bisa digunakan untuk menginstal sistem operasi dari file ISO, seperti Windows, Linux, atau bahkan alat pemulihan sistem lainnya. Ini berguna jika komputer tidak memiliki DVD drive atau ingin menggunakan USB yang lebih cepat.\nMendukung Berbagai Sistem Operasi: Rufus mendukung pembuatan USB bootable untuk berbagai sistem operasi, termasuk Windows, Linux, dan alat-alat lainnya, seperti UEFI (Unified Extensible Firmware Interface) atau BIOS yang lebih lama.\nMendukung Berbagai File Sistem: Rufus mendukung berbagai format file sistem, termasuk FAT32, NTFS, exFAT, dan UDF, yang memungkinkan kompatibilitas dengan berbagai jenis perangkat dan sistem operasi.\nMendukung Boot dengan UEFI dan Legacy BIOS: Rufus dapat membuat USB yang kompatibel dengan mode UEFI (untuk komputer yang lebih baru) dan mode Legacy BIOS (untuk komputer yang lebih lama), memberi fleksibilitas untuk digunakan di berbagai jenis komputer.\nKecepatan Tinggi: Salah satu keunggulan Rufus adalah kecepatannya dalam membuat USB bootable. Dibandingkan dengan beberapa alat lain, Rufus dikenal lebih cepat dalam menyalin file dan membuat USB menjadi bootable.\nMendukung Alat Pemulihan dan Diagnostik: Selain untuk menginstal sistem operasi, Rufus juga bisa digunakan untuk membuat media pemulihan atau alat diagnostik untuk memperbaiki masalah di komputer.\nAntarmuka Pengguna yang Sederhana: Rufus memiliki antarmuka yang sangat sederhana dan mudah dipahami, bahkan untuk pengguna yang tidak berpengalaman.\nDengan antarmuka yang sederhana dan efisien, Rufus sangat ideal bagi pengguna yang membutuhkan alat cepat dan andal untuk membuat USB bootable, baik untuk keperluan instalasi sistem operasi atau pemulihan sistem. Yuk langsung simak bagaimana cara membuat usb bootable menggunakan rufus.\nLangkah-Langkah Membuat USB Bootable menggunakan Rufus: Langkah 1: Unduh dan Install Rufus Unduh Rufus: Kunjungi situs resmi Rufus http://rufus.ie dan unduh versi terbaru. Rufus biasanya tidak memerlukan instalasi karena berupa aplikasi portable.\nJalankan Rufus: Klik dua kali pada file rufus.exe untuk membukanya Langkah 2: Siapkan USB Flash Drive Hubungkan USB Drive: Masukkan USB ke port komputer.\nâš ï¸ Perhatian: Data pada USB akan terhapus.\nPastikan USB Terdeteksi: Rufus akan secara otomatis menampilkan USB drive Anda pada bagian Device. Langkah 3: Pilih File ISO dan Konfigurasi Pilih ISO: Klik tombol Select di bagian Boot Selection, lalu pilih file ISO sistem operasi (Windows, Linux, dll.) yang akan digunakan.\nPilih Skema Partisi dan Target Sistem: Untuk BIOS Pilih MBR \u0026amp; Untuk UEFI Pilih GPT.\nFormat Opsi: File System: Pilih FAT32 atau NTFS (sesuai kebutuhan). Cluster Size: Biarkan default. Langkah 4: Mulai Membuat Bootable USB Klik Start: Tekan tombol Start untuk memulai proses. Konfirmasi Penghapusan Data: Rufus akan memberikan peringatan bahwa data di USB akan dihapus. Klik OK untuk melanjutkan. Proses Pembuatan: Tunggu hingga Rufus selesai membuat bootable USB. Selesai: Ketika proses selesai, Rufus akan menampilkan status Ready. Langkah 5: Gunakan USB Bootable Restart komputer dan masuk ke BIOS/UEFI (biasanya dengan menekan tombol F2, F12, atau DEL saat booting).\nPilih USB sebagai media boot.\nMulai instalasi sistem operasi.\nKesimpulan Rufus adalah solusi terbaik untuk membuat USB bootable secara cepat dan efisien, baik untuk instalasi sistem operasi maupun alat pemulihan. Aplikasi ini ideal untuk pengguna yang membutuhkan alat andal dengan kompatibilitas luas.\n","permalink":"https://catatandeveloper.id/tutorial-membuat-usb-bootable-menggunakan-rufus/","title":"Tutorial Membuat USB Bootable Menggunakan Rufus"},{"content":" PostgreSQL adalah salah satu sistem manajemen basis data relasional (RDBMS) open-source yang paling populer dan kuat. Jika Anda sedang mengembangkan aplikasi yang memerlukan penyimpanan data, PostgreSQL adalah pilihan yang sangat baik. Pada artikel ini, kita akan membahas cara menginstal PostgreSQL di sistem operasi Ubuntu.\nInstalasi perbarui sistem ubuntu Sebelum menginstal perangkat lunak baru, pastikan sistem kamu diperbarui. Buka terminal dan jalankan perintah berikut untuk memperbarui sistem kamu. $ sudo apt update $ sudo apt upgrade\nUntuk menginstal PostgreSQL, kamu bisa langsung menggunakan paket yang tersedia di repositori Ubuntu. Jalankan perintah berikut: $ sudo apt install postgresql postgresql-contrib\npostgresql: Ini adalah paket utama untuk PostgreSQL. postgresql-contrib: Berisi modul tambahan untuk memperluas fungsionalitas PostgreSQL, seperti ekstensi untuk pengolahan data JSON atau pengoptimalan kinerja. check status check menggunakan systemD, apakah service postgresql sudah berjalan. $ sudo systemctl status postgresql\nstart postgresql jika belum berjalan maka jalankan service pada postgresql seperti berikut. $ sudo systemctl start postgresql.service\nMengakses PostgreSQL Setelah instalasi selesai, kita akan masuk dengan menggunakan postgres, secara default PostgreSQL membuat user sistem bernama postgres. user ini memiliki hak akses penuh untuk mengelola database PostgreSQL. Untuk mengakses PostgreSQL, jalankan perintah berikut untuk beralih ke pengguna postgres:\n$ sudo -i -u postgres psql Membuat Database dan Pengguna Baru Sekarang Anda sudah berada di dalam PostgreSQL, mari buat database dan pengguna baru untuk digunakan dalam aplikasi kamu.\nbuat database baru Untuk membuat database baru, gunakan perintah SQL berikut: postgres=# CREATE DATABASE nama_db;\nGantilah nama_db dengan nama yang sesuai untuk database kamu.\nbuat user baru postgres=# CREATE USER user_kamu WITH password \u0026#39;password_anda\u0026#39;; Gantilah nama_pengguna dengan nama pengguna yang Anda inginkan dan password dengan kata sandi yang kuat.\nubah kepemilikan database postgres=# ALTER DATABASE nama_db OWNER TO user_kamu; dengan ini database adalah milik user baru, kamu bisa mengabaikan untuk memberikan hak akses ke user.\nMemberikan Hak Akses pada Pengguna Sekarang berikan hak akses kepada pengguna tersebut untuk mengelola database yang baru saja kamu buat. Jalankan perintah berikut: postgres=# GRANT ALL PRIVILEGES ON DATABASE nama_db TO user_kamu;\nIni memberikan hak akses penuh ke database yang baru saja Anda buat.\nPeriksa dan keluar kamu bisa memeriksa apakah user benar-benar sudah ada belum dengan menggunakan perintah berikut: postgres=# \\du\njika sudah selesai kamu bisa keluar dengan cara seperti ini: postgres=# \\q\nMasuk dengan user baru kamu sekarang bisa masuk dengan user yang telah kamu buat diatas, dengan cara mengetikan seperti berikut: $ psql -U user_kamu -d nama_db\nHapus Instalasi jika kamu mau hapus instalasi postgresql caranya cukup mudah yaitu: $ sudo apt-get --purge remove postgresql postgresql-*\ndengan ini kamu sudah bisa menginstall dan menghapus postgresql ğŸ‰ğŸ‰ğŸ‰.\n","permalink":"https://catatandeveloper.id/cara-install-postgresql-ubuntu/","title":"Cara Install Postgresql Ubuntu"},{"content":" Sebelum kita membahas arduino ada baiknya kamu mempelajari tentang c++ disini terlebih dahulu biar lebih mudah untuk memahaminya.\nArduino IDE pada gambar diatas bisa dilihat bahwa arduino memiliki default function setup dan loop.\nvoid setup() digunakan untuk melakukan inisialisi program seperti sensor, servo maupun komponen lain seperti lcd. void loop() digunakan untuk menjalakan program terus menerus secara tak hingga, ini berarti selama arduino menyala maka program loop akan berjalan Contoh Program mari kita coba untuk melakukan program sederhana di arduino dengan menyalakan lampu LED yang tertanam pada arduino\nKonfigurasi Board klik tools -\u0026gt; board -\u0026gt; Arduino AVR Boards -\u0026gt; Arduino uno. Konfigurasi Port klik tools -\u0026gt; port -\u0026gt; pilih port arduino jika board dan port sudah siap maka kita tinggal program, sebelum memulainya kita lihat gambar berikut dulu, karena pengetahuan datasheet di elektronika sangat penting. pada gambar diatas bisa kita lihat LED yang berwarna kuning berada di pin nomer 13. sehingga kita akan melakukan perintah di pin 13 untuk mengontrol LED.\nbuat program seperti dibawah: const int LED_INTERNAL = 13; void setup() { pinMode(LED_INTERNAL, OUTPUT); } void loop() { digitalWrite(LED_INTERNAL, HIGH); }\nklik upload dan tunggu sampai selesai, maka led yang berwana orange akan menyala seperti gambar dibawah: Penjelasan Program const int LED_INTERNAL = 13; mendeklarasikan variable LED_INTERNAL dengan pin 13, ingat ya const berarti nilai tersebut tidak bisa dirubah. pinMode(LED_INTERNAL, OUTPUT); membuat mode pada variable LED_INTERNAL sebagai output. Hal ini wajib dilakukan jika komponen yang digunakan ditujukan untuk output. digitalWrite(LED_INTERNAL, HIGH); mengirim sinyal digital pada variable LED_INTERNAL menjadi HIGH, atau mengirim tegangan 5v pada pin 13. Tips di dalam arduino IDE jika anda menginginkan pin LED internal ada bisa memanggil variable LED_BUILTIN, mari kita ubah programnya dan sedikit berikan improvement.\nvoid setup() { pinMode(LED_BUILTIN, OUTPUT); } void loop() { digitalWrite(LED_BUILTIN, HIGH); delay(1000); digitalWrite(LED_BUILTIN, LOW); delay(1000); } klik upload dan tunggu sampai selesai, maka led akan melakukan blinking dalam range 1 detik, ini dikarenakan kita memakai delay 1000 = 1detik.\nselamat kamu sudah mengetahui gimana arduino bekerja. Temukan materi arduino lain disini ğŸ‰ğŸ‰ğŸ‰\n","permalink":"https://catatandeveloper.id/memulai-arduino/","title":"Memulai Arduino"},{"content":" Dalam bahasa pemrograman C++, input dan output adalah dua operasi dasar yang sering digunakan untuk berinteraksi dengan pengguna atau perangkat lain. Operasi ini biasanya dilakukan dengan menggunakan standar library iostream yang menyediakan fungsionalitas untuk membaca data (input) dan menulis data (output).\nInput dan Output sederhananya input adalah masukan yang diterima dari terminal sehingga datanya bisa diolah di dalam kode, sedangkan output adalah data keluaran yang di tampilkan di terminal, berikut contoh input dan output:\n#include \u0026lt;iostream\u0026gt; int main() { int number; std::cout \u0026lt;\u0026lt; \u0026#34;masukan angka : \u0026#34;; std::cin \u0026gt;\u0026gt; number; std::cout \u0026lt;\u0026lt; \u0026#34;angka yang anda masukan adalah : \u0026#34; \u0026lt;\u0026lt; number \u0026lt;\u0026lt; std::endl; return 0; } compile dan running programnya\n$ g++ main.cpp $ ./a.out maka hasilnya seperti berikut: Penjelasan cin: Digunakan untuk mengambil input dari pengguna. Pada contoh ini, cin digunakan untuk menerima input angka dan menyimpannya dalam variabel angka. \u0026ldquo;\u0026raquo;\u0026rdquo; : Operator ini digunakan untuk mengarahkan input dari cin ke variabel yang sesuai. cout: Digunakan untuk menampilkan pesan kepada pengguna. perlu kita ingat kembali ya \u0026ldquo;std::\u0026rdquo; adalah namespace dari standart library c++, jadi jika tidak menggunakan \u0026ldquo;using namespace std;\u0026rdquo; maka kamu harus memakai \u0026ldquo;std::\u0026rdquo; atau namespace setiap pemanggilan standart library.\nContoh lain #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; int main() { std::string name; std::cout \u0026lt;\u0026lt; \u0026#34;masukan nama anda : \u0026#34;; std::cin \u0026gt;\u0026gt; name; if(name == \u0026#34;dnan\u0026#34;) std::cout \u0026lt;\u0026lt; \u0026#34;Hallo : \u0026#34; \u0026lt;\u0026lt; name \u0026lt;\u0026lt; std::endl; return 0; } compile dan running programnya\n$ g++ main.cpp $ ./a.out maka hasilnya seperti berikut: selamat kamu sudah mempelajari apa itu input dan output di c++, temukan materi c++ lain di link berikut ğŸ‰ğŸ‰ğŸ‰\n","permalink":"https://catatandeveloper.id/input-output-c++/","title":"Input Output C++"},{"content":" variabel adalah wadah atau tempat untuk menyimpan data sementara dalam memori komputer. Ketika program dijalankan, variabel menyimpan nilai yang bisa digunakan dalam operasi dan perhitungan. Variabel ini memiliki nama, tipe data, dan nilai.\nTipe Data Variabel di C++ Key Name Description Size Range int integer bilangan bulat 4 byte -2147483648 - 2147483647 char character sebuah huruf 1 byte -128 - 127 atau 0 to 255 (jika unsigned) bool boolean logika true dan false 1 byte 1 atau 0 float floating bilangan desimal 4 byte Â±3.4 Ã— 10^38, 6-9 digit void void tanpa nilai 4 byte disistem 32 bit, dan 8 byte di disistem 64 bit - double double menambah size untuk float 8 byte di sistem 64 bit Â±1.7 Ã— 10^308, 15-17 digit long long menambah size pada bilangan bulat 4 byte disistem 32 bit, dan 8 byte di disistem 64 bit -2147483648 - 2147483647 unsigned unsigned menyimpan non negatif 4 byte 0 hingga 4,294,967,295 std::string string kumpulan dari karakter jumlah char - Contoh deklarasi variabel di C++: int number; // deklarasi variabel bertipe integer number = 5; // menetapkan nilai 5 pada variabel Pada contoh di atas, variabel \u0026ldquo;number\u0026rdquo; dideklarasikan dengan tipe data int (integer), yang berarti hanya dapat menyimpan bilangan bulat. Kemudian, variabel \u0026ldquo;number\u0026rdquo; diberi nilai 5.\ncontoh penggunaan type data lain:\nint number = 5; char dataChar = \u0026#39;a\u0026#39;; float dataFloat = 3.14; double dataDouble = 3.14444; long dataLong = 12343456567; // kamu bisa menggabungkan seperti berikut long int longNumber = 1233444555666; Check sizenya #include \u0026lt;iostream\u0026gt; int main() { int number; std::cout \u0026lt;\u0026lt; sizeof(number) \u0026lt;\u0026lt; std::endl; return 0; } compile dan running programnya\n$ g++ main.cpp $ ./a.out maka hasilnya adalah 4. Itu menandakan size dari int adalah 4 byte. ğŸš€ğŸš€ğŸš€\n","permalink":"https://catatandeveloper.id/variable-c++/","title":"Variable C++"},{"content":" Sebelum kita membahas yang lain, kita perlu mencoba jalankan c++ terlebih dahulu untuk memastikan c++ berjalan di komputer kita dengan baik.\ndimateri tentang c++ ini kami akan menggunakan OS linux, jika kalian menggunakan windows dan melakukan instalasi seperti dimateri kami maka caranya akan sama saja ya.\nmari mencoba dengan menuliskan \u0026ldquo;Hello world\u0026rdquo; seperti kode berikut:\n#include \u0026lt;iostream\u0026gt; int main() { std::cout \u0026lt;\u0026lt; \u0026#34;Hello World\u0026#34; \u0026lt;\u0026lt; std::endl; return 0; } compile kode c++ dengan cara: $ g++ main.cpp\nmaka output akan terbuat sehingga kamu bisa langsung mengeksekusi dengan cara $ ./a.out\nmaka hasil keluaran adalah \u0026ldquo;Hello World\u0026rdquo;.\nkamu bisa membuat output nama sesuai yang kamu inginkan, contoh kita akan membuat output dengan nama \u0026ldquo;coba\u0026rdquo;. maka cara menjalakannya seperti ini.\n$ g++ main.cpp -o coba $ ./coba dan hasil sama seperti di atas. mari kita breakdown satu-persatu.\n1. Header #include \u0026lt;iostream\u0026gt; memanggil library (#include) seperti cara diatas berarti memanggil semua yang bersifat public dilibrary tersebut. Hal ini kita butuhkan karena kita ingin mengakses cout yang berada pada library iostream, library pada c++ sendiri atau standart library(STL) sangatlah kaya, jadi kamu bisa mencoba mengakses sendiri sesuai kebutuhan link.\n1. Entry Point int main() { } Entry point dalam sebuah program C++ adalah tempat di mana eksekusi program dimulai. Dalam C++, entry point ditandai dengan fungsi main(). Fungsi ini adalah bagian yang sangat penting karena setiap program C++ akan mulai menjalankan kode dari fungsi main().\n3. Output { std::cout \u0026lt;\u0026lt; \u0026#34;Hello World\u0026#34; \u0026lt;\u0026lt; std::endl; } \u0026ldquo;cout\u0026rdquo; adalah sebuah object di c++ yang digunakan untuk menampilkan output kelayar, sedangkan \u0026ldquo;endl\u0026rdquo; digunakan untuk membuat enter pada layar sehingga lebih rapi.\ndari cara yang kita gunakan diatas kita tidak mendeklarasikan namespace. ingat meskipun memudahkan dalam penulisan kode, pendeklarasian namespace cukup berbaya jika digunakan.\nhal ini akan menyebabkan pemanggilan isi keseluruhan yang menyebabkan program ambigu jika mempunyai namespace yang sama, jadi kita biasakan jangan mendeklasikan namespace seperti berikut: using namespace std; int main() { }\ndengan memahami cara memulai c++ kamu akan lebih mudah untuk melakukan penulisan kode yang baik dan benar, mari kita lanjut ke materi berikutnya. ğŸš€ğŸš€ğŸš€\n","permalink":"https://catatandeveloper.id/memulai-c++/","title":"Memulai C++"},{"content":" Arduino adalah sebuah platform perangkat keras dan perangkat lunak sumber terbuka yang memungkinkan Anda untuk membuat proyek elektronik dengan mudah. Platform ini dirancang agar dapat digunakan oleh para penggemar, pemula, maupun profesional untuk mengembangkan aplikasi elektronika, dari yang sederhana hingga yang lebih kompleks.\nApa itu Arduino? Arduino adalah mikrokontroler atau papan sirkuit cetak (PCB) yang dapat diprogram untuk melakukan berbagai tugas, seperti mengontrol motor, membaca sensor, atau menghubungkan perangkat lain. Papan Arduino ini berfungsi sebagai \u0026ldquo;otak\u0026rdquo; dalam proyek elektronika, yang memungkinkan pengguna untuk memprogramnya untuk melakukan berbagai perintah sesuai dengan input yang diterima.\nAda berbagai jenis papan Arduino yang tersedia, seperti Arduino Uno, Arduino Mega, Arduino Nano, dan lainnya. Setiap papan memiliki spesifikasi yang berbeda-beda, seperti jumlah pin input/output, jumlah memori, dan kemampuan komunikasi.\nKomponen Utama Arduino Mikrokontroler: Otak dari Arduino yang berfungsi untuk menjalankan program. Pada Arduino Uno, misalnya, menggunakan mikrokontroler ATmega328P. Pin Input/Output (I/O): Pin-pin ini memungkinkan Anda untuk menghubungkan berbagai komponen elektronik seperti sensor, motor, LED, dan lain-lain. Port USB: Digunakan untuk menghubungkan Arduino ke komputer, tempat Anda akan menulis dan mengunggah program. Regulator Tegangan: Untuk memastikan Arduino mendapatkan pasokan daya yang stabil, terlepas dari sumber daya yang digunakan (seperti USB atau adaptor daya eksternal). Apa yang Membuat Arduino Menarik? Arduino berfungsi dengan cara menerima sinyal input (misalnya, dari sensor) dan mengeluarkan sinyal output (misalnya, menyalakan LED atau menggerakkan motor) berdasarkan program yang ditulis. Untuk memprogram Arduino, Anda perlu menggunakan Arduino IDE (Integrated Development Environment), sebuah aplikasi yang memungkinkan Anda menulis dan mengunggah kode ke papan Arduino.\nArduino telah menjadi sangat populer di kalangan pembuat perangkat keras (makers), pengembang, dan pendidik karena beberapa alasan:\nSumber Terbuka Komunitas Besar Kemudahan Penggunaan Biaya Terjangkau Kompatibilitas dengan Banyak Sensor dan Modul Kesimpulan Arduino adalah platform yang sangat fleksibel dan mudah diakses untuk siapa saja yang tertarik untuk membuat proyek elektronika. Baik untuk pemula yang ingin belajar tentang elektronika dan pemrograman, atau bagi mereka yang berpengalaman yang ingin mengembangkan ide inovatif, Arduino menyediakan alat dan dukungan yang dibutuhkan untuk merealisasikan proyek-proyek kreatif. Dengan dukungan komunitas yang besar dan berbagai sumber daya yang tersedia, Arduino terus berkembang menjadi salah satu platform paling populer dalam dunia elektronika.\n","permalink":"https://catatandeveloper.id/pengenalan-arduino/","title":"Pengenalan Arduino"},{"content":" C++ merupakan bahasa pemrograman yang multiplatform sehingga bisa di install di semua sistem operasi, seperti windows, linux, mac dan juga bsd. Berikut instalasi c++ pada windows dan linux.\nAlur Pemrograman Alur dari pemrograman c++ adalah:\nkita membuat atau mengedit kode menggunakan kode editor, bisa menggunakan nano, vim, notepad++, vs code, atau kode editor lain sesuai yang kalian suka.\nkemudian file c++ akan di compile menggunakan compiler, seperti GNU dan Clang untuk membuat file eksekusi\nkemudian file eksekusi yang nantinya akan kita jalankan sebagai program\nInstalasi Kode Editor kami menyarankan untuk menggunakan kode editor yang umum digunakan yaitu vs code dengan mengunduhnya disini.\nInstalasi Compiler Windows MinGW adalah kompiler C/C++ asli (GCC) yang memiliki pustaka yang dapat didistribusikan secara gratis untuk membangun aplikasi diWindows. Dalam pembelajaran ini kita akan menggunakan MinGW sebagai compiler pemrograman kita.\nunduh MingW pada link ini. klik 2 kali untuk mengeksekusi MinGW.exe klik install. pilih penempatan folder, secara default di C:\\MinGW kemudian continue pilih MinGW Base System dan g++ compiler (bisa anda lihat di Description) klik instalastion -\u0026gt; apply changes -\u0026gt; apply tunggun proses sampai selesai masukan bin dalam path windows dengan masuk ke environment. pilih path dan edit. klik edit dan masukan C:\\MinGW\\bin dan klik OK. kemudian check dengan membuka CMD dan mengetikan \u0026ldquo;g++\u0026rdquo; jika hasil sesui dengan gambar dibawah maka proses instalasi telah berhasil ğŸ‰ğŸ‰ğŸ‰. Linux pada os linux instalasi g++ umumnya sudah terinstall secara default. tetapi jika anda mengetikan \u0026ldquo;g++\u0026rdquo; dan hasilnya \u0026ldquo;command not found\u0026rdquo; berarti c++ belum terinstal di komputer kalian.\ninstall c++ $ sudo apt install g++\nselamat sekarang c++ sudah terinstal di komputer kalian ğŸ‰ğŸ‰ğŸ‰. Lanjut ke materi selanjutnya!.\n","permalink":"https://catatandeveloper.id/instalasi-c++/","title":"Instalasi C++"},{"content":" C++ adalah salah satu bahasa pemrograman yang paling populer dan banyak digunakan di dunia. Dikembangkan oleh Bjarne Stroustrup pada awal 1980-an di Bell Labs, C++ merupakan bahasa pemrograman yang memiliki kekuatan besar dalam hal fleksibilitas, efisiensi, dan kemampuan untuk mengelola sumber daya komputer secara langsung. C++ adalah pengembangan dari bahasa C, dengan menambahkan konsep objek dan pemrograman berorientasi objek (OOP).\nC++ digunakan untuk mengembangkan berbagai aplikasi, mulai dari perangkat lunak desktop, game, hingga sistem operasi dan perangkat keras seperti IoT, Robotika, otomatisasi dan lainnya.\nKeunggulan utamanya adalah kemampuannya untuk memberikan kontrol yang lebih besar terhadap sistem dan performa aplikasi, menjadikannya pilihan utama dalam pengembangan perangkat lunak yang membutuhkan kecepatan dan efisiensi.\nFitur Utama C++ Pemrograman Berorientasi Objek (OOP) Salah satu fitur utama C++ adalah pemrograman berorientasi objek. Dengan OOP, C++ memungkinkan kamu untuk membuat struktur data (objek) yang dapat mencakup data dan fungsi. Konsep seperti kelas, objek, enkapsulasi, pewarisan, dan polimorfisme menjadi bagian integral dalam pengembangan aplikasi.\nPengelolaan Memori yang Efisien C++ memberikan pengembang kontrol langsung terhadap memori, memungkinkan manajemen alokasi dan dealokasi memori secara manual menggunakan pointer. Ini menjadikan C++ sangat efisien dalam hal penggunaan sumber daya komputer.\nPerforma Tinggi C++ dikenal dengan kemampuannya untuk memberikan performa tinggi. Kode yang ditulis dalam C++ dapat berjalan lebih cepat dibandingkan dengan bahasa pemrograman tingkat tinggi lainnya karena C++ menghasilkan kode yang lebih dekat dengan perangkat keras.\nMulti-Paradigma C++ mendukung berbagai paradigma pemrograman, mulai dari prosedural, berorientasi objek, hingga generik (dengan template). Hal ini memberi fleksibilitas bagi pengembang untuk memilih gaya pemrograman yang paling sesuai dengan kebutuhan aplikasi mereka.\nKompatibilitas dengan C Karena C++ adalah pengembangan dari bahasa C, kode yang ditulis dalam bahasa C dapat dikompilasi dan dijalankan dalam C++ tanpa modifikasi besar. Hal ini memungkinkan pengembang untuk memanfaatkan pustaka dan kode lama yang sudah ada dalam bahasa C.\nPustaka Standard Template Library (STL) C++ dilengkapi dengan pustaka bawaan yang kuat, yaitu STL (Standard Template Library). STL menyediakan struktur data seperti vector, list, queue, dan stack, serta algoritma untuk pencarian dan manipulasi data. Pustaka ini membuat pengembangan aplikasi menjadi lebih cepat dan efisien.\nKelebihan C++ 1. Kecepatan: C++ adalah salah satu bahasa yang paling cepat, menjadikannya pilihan utama dalam pengembangan aplikasi yang memerlukan pemrosesan data yang besar atau game dengan grafis 3D yang kompleks.\n2. Kontrol Penuh: C++ memberi pengembang kontrol penuh atas pengelolaan memori dan sistem, yang sangat penting dalam pengembangan perangkat lunak yang membutuhkan kinerja tinggi.\n3. Portabilitas: Program yang ditulis dalam C++ dapat dijalankan di berbagai platform, dari sistem operasi Windows, Linux, hingga macOS, tanpa perubahan besar.\n4. Komunitas Besar: C++ memiliki komunitas pengembang yang besar, yang berarti kamu akan mudah menemukan sumber daya, tutorial, dan dukungan ketika mengalami masalah dalam pemrograman.\nKekurangan C++ 1. Kesulitan dalam Manajemen Memori: Meskipun memberikan kontrol yang lebih besar terhadap memori, C++ juga mengharuskan pengembang untuk mengelola memori secara manual, yang bisa berisiko menyebabkan kebocoran memori jika tidak dikelola dengan hati-hati.\n2. Kompleksitas: Karena sifatnya yang fleksibel dan banyaknya fitur, C++ dapat menjadi sulit dipelajari, terutama bagi pemula.\n3. Kurangnya Fitur Keamanan: C++ tidak menyediakan mekanisme untuk menangani beberapa masalah keamanan seperti pemrograman tingkat tinggi lainnya.\nPenggunaan C++ C++ digunakan di berbagai bidang, antara lain:\nPengembangan Game. Aplikasi Desktop. Sistem Operasi dan Driver. IoT. Robotika. Kesimpulan C++ adalah bahasa pemrograman yang powerful dan efisien, sangat cocok untuk aplikasi yang memerlukan kontrol lebih besar terhadap perangkat keras dan performa tinggi. Dengan fitur-fitur seperti OOP, pengelolaan memori yang efisien, dan pustaka STL yang kaya, C++ tetap menjadi pilihan utama dalam banyak sektor pengembangan perangkat lunak. Meskipun memiliki tahap pembelajaran yang cukup susah, bagi pengembang berpengalaman, C++ adalah alat yang sangat berguna untuk menciptakan perangkat lunak berkinerja tinggi.\n","permalink":"https://catatandeveloper.id/pengenalan-c++/","title":"Pengenalan C++"},{"content":" Pada hard disk, GPT (GUID Partition Table) dan MBR (Master Boot Record) adalah dua jenis sistem partisi yang digunakan untuk mengatur dan mengelola bagaimana data disimpan di dalam drive. Berikut adalah pengertian dan perbedaan antara keduanya:\n1. GPT (GUID Partition Table): Pengertian: GPT adalah sistem partisi yang lebih modern dan lebih canggih daripada MBR. GPT adalah bagian dari standar UEFI (Unified Extensible Firmware Interface), yang menggantikan BIOS pada komputer modern. GPT menggunakan GUID (Globally Unique Identifier) untuk setiap partisi, yang memastikan bahwa setiap partisi memiliki ID unik di seluruh dunia.\nFitur Utama:\nDukungan untuk jumlah partisi yang lebih banyak: GPT dapat mendukung hingga 128 partisi pada satu disk, tanpa memerlukan ekstensi atau partisi tambahan. Ukuran kapasitas yang lebih besar: GPT mendukung disk dengan kapasitas lebih besar dari 2 TB (terbatas oleh MBR). Backup Header: GPT menyimpan salinan cadangan dari struktur partisi di awal dan akhir disk, sehingga lebih tahan terhadap kerusakan atau kehilangan data. Keamanan: GPT lebih tahan terhadap kerusakan dan lebih stabil, dengan menyimpan informasi lebih banyak tentang struktur disk. 2. MBR (Master Boot Record): Pengertian: MBR adalah sistem partisi yang lebih lama, yang digunakan sejak era BIOS. MBR menyimpan informasi tentang partisi dalam sebuah sektor khusus di awal disk yang disebut Master Boot Record. MBR memiliki keterbatasan yang tidak ditemukan pada GPT.\nFitur Utama:\nJumlah partisi terbatas: MBR hanya dapat mendukung hingga 4 partisi primer atau 3 partisi primer dan 1 partisi ekstensi yang dapat dibagi menjadi partisi logis. Kapasitas terbatas: MBR hanya mendukung disk dengan ukuran hingga 2 TB. Lebih besar dari itu, kapasitasnya tidak dapat digunakan. Backup minim: MBR tidak menyimpan salinan cadangan struktur partisi, sehingga lebih rentan terhadap kerusakan. Kompatibilitas dengan BIOS: MBR digunakan pada sistem yang masih menggunakan BIOS untuk proses booting, yang lebih tua dibandingkan UEFI yang menggunakan GPT. Perbedaan Utama antara GPT dan MBR: Fitur GPT MBR Jumlah Partisi Mendukung hingga 128 partisi Maksimum 4 partisi primer Ukuran Disk Mendukung disk lebih besar dari 2 TB Maksimum 2 TB Keamanan Menyimpan salinan cadangan dari header Tidak ada cadangan (hanya 1 header) Kompatibilitas Digunakan dengan UEFI Digunakan dengan BIOS Struktur Data Menggunakan GUID untuk setiap partisi Menggunakan ID 32-bit untuk partisi Fleksibilitas Lebih fleksibel dan lebih baru Terbatas dan lebih tua Kesimpulan: GPT lebih unggul dalam hal kapasitas disk yang didukung, jumlah partisi, dan ketahanan terhadap kerusakan data, sehingga lebih cocok untuk komputer modern dan disk berkapasitas besar. MBR lebih tua dan memiliki keterbatasan baik dalam hal jumlah partisi maupun kapasitas disk. Namun, MBR masih digunakan pada sistem yang lebih lama dan pada komputer yang menggunakan BIOS. Jika Anda menggunakan disk dengan kapasitas besar atau komputer yang mendukung UEFI, maka GPT adalah pilihan yang lebih baik. Semoga penjelasan ini membantu!\n","permalink":"https://catatandeveloper.id/perbedaan-partisi-gpt--mbr/","title":"Perbedaan Partisi GPT \u0026 MBR"},{"content":" UEFI (Unified Extensible Firmware Interface) dan Legacy BIOS adalah dua jenis firmware yang digunakan oleh komputer untuk menginisialisasi perangkat keras dan memulai sistem operasi. Keduanya berfungsi pada tahap booting komputer, tetapi mereka memiliki perbedaan signifikan dalam cara mereka bekerja dan kemampuannya.\n1. UEFI (Unified Extensible Firmware Interface) UEFI adalah pengganti dari BIOS tradisional yang menawarkan lebih banyak fitur dan fleksibilitas. Berikut adalah beberapa karakteristik dari UEFI:\nAntarmuka grafis: UEFI mendukung antarmuka grafis dan bisa menggunakan mouse, sedangkan BIOS tradisional hanya berbasis teks dan menggunakan keyboard. Kompatibilitas 64-bit: UEFI mendukung arsitektur 64-bit, memungkinkan akses lebih besar terhadap memori dan meningkatkan kinerja. Waktu boot lebih cepat: UEFI memungkinkan komputer untuk memulai sistem operasi dengan lebih cepat daripada BIOS. Partisi Disk: UEFI menggunakan skema partisi GPT (GUID Partition Table), yang memungkinkan lebih banyak partisi pada hard drive (lebih dari empat) dan mendukung disk lebih besar dari 2 TB. Keamanan: UEFI memiliki fitur keamanan yang lebih canggih, seperti Secure Boot, yang mencegah perangkat lunak yang tidak sah atau malware untuk mengakses komputer saat booting. Driver dan Program Eksternal: UEFI dapat memuat driver dan program eksternal saat proses booting. 2. Legacy BIOS BIOS (Basic Input/Output System) adalah firmware yang lebih tua yang telah digunakan selama beberapa dekade. Meskipun telah digantikan oleh UEFI di banyak sistem, BIOS masih digunakan pada beberapa komputer lama. Berikut adalah beberapa karakteristik dari BIOS:\nAntarmuka berbasis teks: BIOS menggunakan antarmuka berbasis teks yang mengandalkan keyboard untuk navigasi. Kompatibilitas 32-bit: BIOS hanya mendukung arsitektur 32-bit, yang membatasi akses ke memori lebih dari 4 GB. Partisi Disk: BIOS menggunakan skema partisi MBR (Master Boot Record), yang hanya mendukung hingga empat partisi primer dan hard disk dengan kapasitas maksimum 2 TB. Boot yang lebih lambat: BIOS biasanya memerlukan waktu yang lebih lama untuk memulai sistem operasi dibandingkan dengan UEFI. Keamanan Terbatas: BIOS tidak memiliki fitur keamanan seperti UEFI, sehingga lebih rentan terhadap ancaman pada tahap booting. Perbedaan Utama: Fitur UEFI Legacy BIOS Antarmuka Partisi Grafis, mendukung mouse Teks, hanya mendukung keyboard Arsitektur 64-bit 2-bit Skema Partisi GPT (GUID Partition Table) MBR (Master Boot Record) Waktu Boot Lebih cepat Lebih lambat Keamanan Secure Boot, lebih aman Tidak ada fitur keamanan seperti UEFI Ukuran Disk Mendukung disk lebih besar dari 2 TB Hanya mendukung disk hingga 2 TB Kesimpulan: UEFI lebih modern, cepat, aman, dan fleksibel dibandingkan dengan Legacy BIOS. Komputer yang lebih baru biasanya menggunakan UEFI, sementara Legacy BIOS lebih umum pada komputer lama. Pengguna dapat memilih mode UEFI atau BIOS tergantung pada kebutuhan sistem, tetapi kebanyakan perangkat keras saat ini lebih menyarankan penggunaan UEFI.\nSemoga penjelasan ini membantu!\n","permalink":"https://catatandeveloper.id/penjelasan-uefi--legacy-bios/","title":"Penjelasan UEFI \u0026 Legacy BIOS"},{"content":" RPC di Git adalah singkatan dari Remote Procedure Call, yang merupakan salah satu mekanisme komunikasi yang digunakan Git untuk berinteraksi antara client dan server dalam operasi jaringan. Pada dasarnya, RPC memungkinkan Git client untuk meminta server menjalankan berbagai prosedur atau layanan tertentu, seperti mem-fetch, mem-push, atau melakukan query pada repositori.\nError: RPC failed umumnya muncul ketika melakukan data transfer menggunakan https yang datanya cukup besar, berikut adalah cara menyelesaikan masalah tersebut.\nGunakan ssh:\n$ git clone git@github.com:opencv/opencv.git ubah url sesuai repository kamu. Biasanya ketika melakukan ssh, problem tersebut bisa teratasi, tapi jika kamu ingin menggunakan https maka ikuti alur berikut.\nUbah http/2 ke http/1.1\n$ git config --global http.version HTTP/1.1 umumnya error RPC menggunakan http/2 kamu dapat memaksa untuk menggunakan http/1.1, ini bisa mencegah problem koneksi stream handling dari http/2.\nCoba gunakan shallow clone\n$ git clone --depth 1 https://github.com/opencv/opencv.git ubah url sesui repository kamu. Cara diatas umumnya bisa mengatasi masalah clone di https yang datanya terlalu besar.\nSize buffer\njika masalah masih terjadi coba untuk menambah size buffer seperti berikut:\n$ git config --global http.postBuffer 1048576000 # 1GB selamat mencoba ğŸ‰ğŸ‰ğŸ‰.\n","permalink":"https://catatandeveloper.id/error-rpc-failed-curl-git-clone/","title":"Error: RPC failed curl git clone"},{"content":" Arduino versi 2.* adalah IDE dengan versi yang sangat baik bagi pengembang elektronika, hal ini karena arduino v2 ini memiliki fitur-fitur yang sangat berguna bagi developer, berikut fitur-fitur Arduino v2 yang perlu kamu tau:\nEditor Modern: Antarmuka lebih bersih, berbasis framework Eclipse Theia, dengan tema gelap/terang.\nAutocomplete dan IntelliSense: Mendukung pelengkapan kode otomatis dan informasi fungsi secara langsung, kamu bisa mengaktifkanya dengan mengklik check pada Editor Quick Suggestions pada preferences\nDebugger Terintegrasi: Bisa melakukan debugging langsung untuk papan Arduino yang mendukung debugging hardware.\nLive Error Highlighting: Kesalahan dalam kode ditandai secara langsung.\nKinerja Lebih Cepat: Waktu kompilasi dan pengunggahan ke board lebih efisien.\nManajemen Library \u0026amp; Board yang Mudah: Antarmuka untuk menambah library atau board lebih intuitif.\nTerminal Serial yang Ditingkatkan: Terminal serial sekarang mendukung multitasking dan visualisasi lebih baik.\nBerikut langkah-langkah instalasi arduino ide v2: Download arduino: kamu bisa mengunjungi situs resmi arduino dan download zip file, atau kamu bisa mendownload menggunakan wget langsung dari terminal seperti berikut:\n$ wget https://downloads.arduino.cc/arduino-ide/arduino-ide_2.3.4_Linux_64bit.zip Ekstrak file yang sudah kamu unduh: $ unzip arduino-ide_2.3.4_Linux_64bit.zip -d arduino-ide Pindahkan file ke direktori /opt untuk pemasangan global: $ sudo mv arduino-ide /opt/arduino-ide $ sudo ln -s /opt/arduino-ide/arduino-ide /usr/local/bin/arduino-ide Install Dependensi yang dibutuhin dulu: sudo apt install libfuse2 libnss3 libatk1.0-0 libx11-xcb1 libgbm1 libxshmfence1 libasound2 Tambahkan Izin Akses ke Port Serial: $ sudo usermod -aG dialout $USER dengan ini kamu bisa langsung menggunakan lewat terminal: $ arduino-ide\nLanjut buat shortcut aplikasi Arduino agar lebih mudah menjalankan dengan linux desktop: $ sudo nano /usr/share/applications/arduino-ide.desktop isi dengan:\n[Desktop Entry] Name=Arduino IDE Comment=Arduino IDE Exec=/opt/arduin-ide/arduino-ide Icon=/opt/arduin-ide/resources/app/resources/icons/512x512.png Terminal=false Type=Application Categories=Development;IDE; simpan dengan ctrl+x kemudian y, lalu enter.\nBuat arduinonya biar bisa di eksekusi: $ sudo chown root:root /opt/arduino-ide/chrome-sandbox $ sudo chmod 4755 /opt/arduino-ide/chrome-sandbox $ sudo chmod +x /opt/arduino-ide/arduino-ide $ sudo chmod +x /usr/share/applications/arduino-ide.desktop Selamat ğŸ‰ğŸ‰, kamu sudah bisa jalanin arduino dari Menu linux nih. ğŸš€ğŸš€ğŸš€\n","permalink":"https://catatandeveloper.id/cara-install-arduino2-pada-ubuntu/","title":"Cara Install Arduino IDE 2.* Pada Ubuntu"},{"content":" Dalam keadaan tertentu mysql sering membuat aplikasi lain mengalami kegagalan atau pada saat melakukan instalasi lamp sering terjadi kesalahan yang mengharuskan kita menginstall ulang mysql. sebelum melakukan instalasi ulang kita sering mengalami kegagalan saat instalasi ini diakibatkan cara menghapus mysql kita yang belum sepenuhnya berhasil.\nberikut adalah cara jitu menghapus mysql di ubuntu:\n$ sudo apt-get remove --purge mysql-\\* sebenarnya dengan kita melakukan perintah di atas kita sudah mengahapus instalan mysql pada ubuntu kita, akan tetapi kadang masih ada yang tersisa, jadi lebih baik kita check terlebih dahulu dengan perintah berikut: $ dpkg -l | grep mysql\ncheck apakah masih ada mysql terinstall, jika masih lakukan pengahapusan satu persatu dengan perintah berikut: $ sudo apt-get --purge autoremove namapackage\nlangkah terakhir adalah mnghapus directory yang ada di ubuntu dengan perintah berikut:\n$ sudo rm -rf /etc/mysql /var/lib/mysql $ sudo apt-get autoremove $ sudo apt-get autoclean dengan ini cara menghapus mysql di ubuntu sudah selesai, jika ingin melakukan install ulang mysql hanya dengan melakukan perintah sebagai berikut:\n$ sudo apt install mysql-server mysql-client ğŸš€ğŸš€ğŸš€\n","permalink":"https://catatandeveloper.id/cara-ampuh-untuk-menghapus-mysql-di-linux/","title":"Cara Ampuh Untuk Menghapus Mysql Di Linux"},{"content":" LAMP merupakan kepanjangan dari Linux, Apache, Mysql , Perl/PHP/Python. Merupakan sebuah paket perangkat lunak bebas yang digunakan untuk menjalankan sebuah aplikasi secara lengkap.\nKegunaan dari LAMP sendiri adalah sebagai server yang mudah di gunakan untuk pemula, yaitu sama seperti XAMP pada windows dan MAMP pada mac.\nPada kesempatan ini kita akan melakukan instalasi lamp dengan menggunakan terminal pada linux hal yang harus di siapkan antara lain:\nubuntu versi 16.04 / 18.04 / latest internet. Di tutorial kali ini kita akan menggunakan ubuntu 16.04, jika teman-teman menggunakan versi 18.04 atau latest akan lebih bagus, ini dikarenakan versi php sudah mendukung versi yang lebih baru, contoh di ubuntu 18.04 itu secara default menggunakan php7.2 sedangkan jika kita menggunakan ubuntu 16.04 maka default yang di install adalah php versi 7.0.\nJika persiapan sudah siap maka langsung saja kita mulai.\nupdate dan install apache2:\n$ sudo apt update $ sudo apt install apache2 setelah melakukan install apache 2 buka browser dan ketiakan alamat 127.0.0.1 atau localhost, kemudian tekan enter maka hasilnya sebagai berikut. Jika gagal atau server tidak bisa padahal proses instalasi sudah selesai maka service belum di aktifkan, ketikan: $ sudo systemctl start apache2\nselanjutnya install mysql:\n$ sudo apt install mysql-server mysql-client ikuti perintah perintahkan seperti ok dan yes dan masukan password kalian. jika sudah selesai check dengan menulis perintah:\n$ sudo mysql -u root -p maka hasilnya: dengan begitu maka MySQL sudah terinstall\nkemudian install php:\n$ sudo apt-get install software-properties-common $ sudo add-apt-repository ppa:ondrej/php jika kamu ingin menginstall secara khusus seperti php versi 7.2 $ sudo apt install php7.2-fpm php7.2-common php7.2-mbstring php7.2-xmlrpc php7.2-soap php7.2-gd php7.2-xml php7.2-intl php7.2-mysql php7.2-cli php7.2-zip php7.2-curl php7.2 libapache2-mod-php7.2 jika kalian ingin menginstall menggunakan php default bawaan bisa menggunakan ini: $ sudo apt install php-fpm php-common php-mbstring php-xmlrpc php-soap php-gd php-xml php-intl php-mysql php-cli php-zip php-curl php libapache2-mod-php jika sudah selesai check dengan menggunakan perintah\n$ php -v maka outputnya seperti di bawah ini: untuk memudahkan pengelolaan database install phpmyadmin:\ninstall phpmyadmin secara default: $ sudo apt-get install phpmyadmin\npilih apache2 dan enter. selalu gunakan password untuk memberi keamanan dan menghindari error.\njika sudah selesai copy phpmyadmin ke html dengan perintah: $ sudo ln -s /usr/share/phpmyadmin /var/www/html/phpmyadmin\nlangkah di atas penting karena akan mengcopy folder php ke server yang di gunakan ubuntu, jika tidak di copy maka phpmyadmin tidak di temukan.\nbuka browser dan masukan url localhost/phpmyadmin masukan username root dan password kalian dan hasilnya sebagai berikut: dengan ini, lamp sudah selesai di buat.\njika ingin melakukan test dengan nama coba.html.\nmasukan file ke /var/www/html/coba.html maka localhost akan otomatis meload file kalian buat dengan url localhost/coba.html\nYang sering terjadi: Password is Forbidden jika kamu mengalami â€œPassword is Forbiddenâ€ PhpMyAdmin Login Error maka kamu harus melakukan ini: $ sudo nano /etc/phpmyadmin/config.inc.php\nhapus comment pada AllowNoPassword seperti gambar diatas, kemudian save dengan cara ctrl+x dan kemudian ketikan \u0026ldquo;y\u0026rdquo;.\n#1698 - Access denied for user \u0026lsquo;root\u0026rsquo;@\u0026rsquo;localhost\u0026rsquo; jika mengalami error #1698 - Access denied for user \u0026lsquo;root\u0026rsquo;@\u0026rsquo;localhost\u0026rsquo; khususnya untuk ubuntu 18.04, maka lakukan:\n$ sudo mysql -u root -p mysql\u0026gt; CREATE USER \u0026#39;nama_user\u0026#39;@\u0026#39;localhost\u0026#39;; mysql\u0026gt; ALTER USER \u0026#39;nama_user\u0026#39;@\u0026#39;localhost\u0026#39; IDENTIFIED WITH mysql_native_password BY \u0026#39;password_user\u0026#39;; mysql\u0026gt; GRANT ALL PRIVILEGES ON *.* TO \u0026#39;nama_user\u0026#39;@\u0026#39;localhost\u0026#39;; mysql\u0026gt; FLUSH PRIVILEGES; mysql\u0026gt; exit kamu bisa melakukan perubahan nama user pada \u0026ldquo;nama_user\u0026rdquo;.\nusername dan password akan mengocopy dari user yang telah di buat, selanjutnya tinggal buka localhost/phpmyadmin dengan username dan password sesuai yang telah di buat.\nğŸš€ğŸš€ğŸš€\n","permalink":"https://catatandeveloper.id/cara-install-lamp-pada-ubuntu18/","title":"Cara Install Lamp Pada Ubuntu 16.04/18.04/latest"}]